package invis.gl.bubbleviewer;

import edu.uci.ics.jung.algorithms.shortestpath.DijkstraShortestPath;
import edu.uci.ics.jung.graph.DirectedSparseMultigraph;
import edu.uci.ics.jung.graph.Graph;
import invis.gl.NetworkClusterApi.NetworkClusterElementApi;
import invis.gl.NetworkClusterApi.NetworkClusterVertexApi;
import invis.gl.NetworkVisualizationViewer.NetworkVisualizationViewer;
import invis.gl.bubbleNodes.BubbleModel;
import invis.gl.bubbleNodes.BubbleNodeFactory;
import invis.gl.dataprocessor.DataParser;
import invis.gl.graphviewer.NetworkDisplayTopComponent;
import invis.gl.graphvisualapi.NetworkDisplayApi.DisplayType;
import invis.gl.networkapi.AllPathDetector;
import invis.gl.networkapi.BubbleApi;
import invis.gl.networkapi.NetworkElementApi;
import invis.gl.networkapi.NetworkVVDisplay;
import invis.gl.networkapi.NodeViewerTopComponentExtension;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.explorer.ExplorerManager;
import org.openide.explorer.ExplorerUtils;
import org.openide.explorer.view.BeanTreeView;
import org.openide.nodes.AbstractNode;
import org.openide.nodes.Children;
import org.openide.nodes.Node;
import org.openide.util.Exceptions;
import org.openide.util.Lookup;
import org.openide.util.NbBundle.Messages;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(
    dtd = "-//invis.gl.bubbleviewer//BubbleViewer//EN",
autostore = false)
@TopComponent.Description(
    preferredID = "BubbleViewerTopComponent",
//iconBase="SET/PATH/TO/ICON/HERE", 
persistenceType = TopComponent.PERSISTENCE_ALWAYS)
@TopComponent.Registration(mode = "leftSlidingSide", openAtStartup = false)
@ActionID(category = "Window", id = "invis.gl.bubbleviewer.BubbleViewerTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(
    displayName = "#CTL_BubbleViewerAction",
preferredID = "BubbleViewerTopComponent")
@Messages(
{
    "CTL_BubbleViewerAction=BubbleViewer",
    "CTL_BubbleViewerTopComponent=BubbleViewer Window",
    "HINT_BubbleViewerTopComponent=This is a BubbleViewer window"
})
public final class BubbleViewerTopComponent extends NodeViewerTopComponentExtension// implements ExplorerManager.Provider
{

    private ExplorerManager mgr = new ExplorerManager();
    //private DataParser mDataParser;
    private DirectedSparseMultigraph<String, String> mGraph;
    private DisplayType mDisplayTypeFlag;

    public BubbleViewerTopComponent()
    {
        this.associateLookup(ExplorerUtils.createLookup(mgr, this.getActionMap()));
        initComponents();
        setName("Bubble Viewer");
        setToolTipText(Bundle.HINT_BubbleViewerTopComponent());
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        CalculateBubblesjbtn = new javax.swing.JButton();
        mRootTextField = new javax.swing.JTextField();
        mBeanTreeView = new javax.swing.JScrollPane();
        mGenerateGraphBtn = new javax.swing.JButton();

        org.openide.awt.Mnemonics.setLocalizedText(CalculateBubblesjbtn, org.openide.util.NbBundle.getMessage(BubbleViewerTopComponent.class, "BubbleViewerTopComponent.CalculateBubblesjbtn.text")); // NOI18N
        CalculateBubblesjbtn.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                CalculateBubblesjbtnActionPerformed(evt);
            }
        });

        mRootTextField.setText(org.openide.util.NbBundle.getMessage(BubbleViewerTopComponent.class, "BubbleViewerTopComponent.mRootTextField.text")); // NOI18N

        mBeanTreeView = new BeanTreeView();

        org.openide.awt.Mnemonics.setLocalizedText(mGenerateGraphBtn, org.openide.util.NbBundle.getMessage(BubbleViewerTopComponent.class, "BubbleViewerTopComponent.mGenerateGraphBtn.text")); // NOI18N
        mGenerateGraphBtn.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                mGenerateGraphBtnActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(mBeanTreeView, javax.swing.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(mRootTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(CalculateBubblesjbtn)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(mGenerateGraphBtn)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(mBeanTreeView, javax.swing.GroupLayout.DEFAULT_SIZE, 283, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(CalculateBubblesjbtn)
                    .addComponent(mRootTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(mGenerateGraphBtn))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void CalculateBubblesjbtnActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_CalculateBubblesjbtnActionPerformed
    {//GEN-HEADEREND:event_CalculateBubblesjbtnActionPerformed
        this.CalculateBubbles();
    }//GEN-LAST:event_CalculateBubblesjbtnActionPerformed

    private boolean VertexContainedInBubble(BubbleApi bubble, String vertex)
    {
        boolean contained = false;
        for (int i = 0; i < bubble.getPaths().size(); i++)
        {
            for (int j = 0; j < bubble.getPaths().get(i).size(); j++)
            {
                String edge = bubble.getPaths().get(i).get(j).getValue();
                String src = mGraph.getSource(edge);
                String dest = mGraph.getDest(edge);
                if (src.compareTo(bubble.getSource().getValue()) == 0)
                {
                }

                if (vertex.compareTo(src) == 0 || vertex.compareTo(dest) == 0)
                {
                    contained = true;
                }

            }
        }
        return (contained);
    }
    private HashMap<NetworkElementApi, String> VertexOneClusterMap = new HashMap<NetworkElementApi, String>();
    private HashMap<NetworkElementApi, String> VertexTwoClusterMap = new HashMap<NetworkElementApi, String>();
    private HashMap<NetworkElementApi, String> BubbleSource_EdgeSetKey = new HashMap<NetworkElementApi, String>();
    private HashMap<NetworkElementApi, String> BubbleSource_VertexSetKey = new HashMap<NetworkElementApi, String>();
    private HashMap<NetworkElementApi, String> BubbleTarget_EdgeSetKey = new HashMap<NetworkElementApi, String>();
    private HashMap<NetworkElementApi, String> BubbleTarget_VertexSetKey = new HashMap<NetworkElementApi, String>();
    private HashMap<String, LinkedList<String>> edgeSetKey_EdgeSet = new HashMap<String, LinkedList<String>>();

    private void BuildClusteredVertex_Edge(BubbleApi bubble)
    {
        for (int depth = 0; depth < bubble.getPaths().get(0).size(); depth++)
        {
            String edgeSetKey = new String();
            LinkedList<String> edgeSet = new LinkedList<String>();
            for (int i = 0; i < bubble.getPaths().size(); i++)
            {
                String edge = bubble.getPaths().get(i).get(depth).getValue();
                edgeSetKey = edgeSetKey.concat(edge);
                edgeSet.add(edge);
            }
            if (depth == 0)
            {
                BubbleSource_EdgeSetKey.put(bubble.getSource(), edgeSetKey);
            }
            if (depth == 1)
            {
                BubbleTarget_EdgeSetKey.put(bubble.getTarget(), edgeSetKey);
            }
            edgeSetKey_EdgeSet.put(edgeSetKey, edgeSet);
            //mDataParser.getDerivedData().BuildNewClusterEdge(edgeSetKey, edgeSet);
        }

        String FirstComponent = mGraph.getDest(bubble.getPaths().get(0).get(0).getValue());
        String SecondComponent = mGraph.getDest(bubble.getPaths().get(1).get(0).getValue());

        String vertexSetKey = new String();
        Collection<String> vertexSet = new LinkedList<String>();

        vertexSet.add(FirstComponent);
        vertexSet.add(SecondComponent);

        vertexSetKey = vertexSetKey.concat(FirstComponent);
        vertexSetKey = vertexSetKey.concat(SecondComponent);

        NetworkElementApi FirstComponentNEA = mDataParser.getNodeTable().get(FirstComponent);
        NetworkElementApi SecondComponentNEA = mDataParser.getNodeTable().get(SecondComponent);

        VertexOneClusterMap.put(FirstComponentNEA, vertexSetKey);
        VertexTwoClusterMap.put(SecondComponentNEA, vertexSetKey);

        BubbleSource_VertexSetKey.put(bubble.getSource(), vertexSetKey);
        BubbleTarget_VertexSetKey.put(bubble.getTarget(), vertexSetKey);

        mDataParser.getDerivedData().BuildNewClusterNode(vertexSetKey, vertexSet);
    }

    private void SourceToClusters(BubbleApi bubble, DirectedSparseMultigraph<String, String> graph)
    {
        String EdgeSetKey = BubbleSource_EdgeSetKey.get(bubble.getSource());
        String BubbleSourceComponentVertexSetKey = BubbleSource_VertexSetKey.get(bubble.getSource());
        String Source = bubble.getSource().getValue();

        //The source is contained in a ClusterVertex created by another bubble, as component one.
        if (VertexOneClusterMap.containsKey(bubble.getSource()))
        {
            Source = VertexOneClusterMap.get(bubble.getSource());
            graph.addEdge(Source + EdgeSetKey + BubbleSourceComponentVertexSetKey, Source, BubbleSourceComponentVertexSetKey);
            mDataParser.getDerivedData().BuildNewClusterEdge(Source + EdgeSetKey + BubbleSourceComponentVertexSetKey, edgeSetKey_EdgeSet.get(EdgeSetKey));
        } //The source is contained in a ClusterVertex created by another bubble, as component two.
        else if (VertexTwoClusterMap.containsKey(bubble.getSource()))
        {
            Source = VertexTwoClusterMap.get(bubble.getSource());
            graph.addEdge(Source + EdgeSetKey + BubbleSourceComponentVertexSetKey, Source, BubbleSourceComponentVertexSetKey);
            mDataParser.getDerivedData().BuildNewClusterEdge(Source + EdgeSetKey + BubbleSourceComponentVertexSetKey, edgeSetKey_EdgeSet.get(EdgeSetKey));
        } //String edgeSet = BubbleSource_EdgeSetKey.get(bubble.getSource());
        else
        {
            graph.addEdge(Source + EdgeSetKey + BubbleSourceComponentVertexSetKey, Source, BubbleSourceComponentVertexSetKey);
            mDataParser.getDerivedData().BuildNewClusterEdge(Source + EdgeSetKey + BubbleSourceComponentVertexSetKey, edgeSetKey_EdgeSet.get(EdgeSetKey));
        }
    }

    private LinkedList<String> getClusterList(String simpleVertex)
    {
        LinkedList<String> ClusterList = new LinkedList<String>();
        Set<String> keySet = mDataParser.getDerivedData().getNodeTable().keySet();
        for (int i = 0; i < keySet.size(); i++)
        {
            boolean contained = false;
            NetworkClusterVertexApi Cluster = mDataParser.getDerivedData().getNodeTable().get(keySet.toArray()[i].toString());

            for (int j = 0; j < Cluster.getNetworkElementSet().size(); j++)
            {
                if (Cluster.getNetworkElementSet().get(j).getValue().compareTo(simpleVertex) == 0)
                //if (Cluster.getNetworkElementSet().contains(simpleVertex))
                {
                    contained = true;
                }
            }
            if (contained)
            {
                ClusterList.add(Cluster.getValue());
            }
        }
        return (ClusterList);
    }

    private void ClustersToTarget(BubbleApi bubble, DirectedSparseMultigraph<String, String> graph)
    {
        String ClusterThatPointsToTarget = BubbleTarget_VertexSetKey.get(bubble.getTarget());

        LinkedList<String> ContainingClusters = getClusterList(bubble.getTarget().getValue());

        if (ContainingClusters.size() > 0)
        {
            for (int TargetClusterItr = 0; TargetClusterItr < ContainingClusters.size(); TargetClusterItr++)
            {
                String edgeSetKey = new String();
                edgeSetKey = edgeSetKey.concat(bubble.getPaths().get(0).get(1).getValue());
                edgeSetKey = edgeSetKey.concat(bubble.getPaths().get(1).get(1).getValue());

                LinkedList<String> edgeSet = new LinkedList<String>();
                edgeSet.add(bubble.getPaths().get(0).get(1).getValue());
                edgeSet.add(bubble.getPaths().get(1).get(1).getValue());

                String ComponentOne = mGraph.getDest(bubble.getPaths().get(0).get(0).getValue());
                String ComponentTwo = mGraph.getDest(bubble.getPaths().get(1).get(0).getValue());

                LinkedList<String> cluster1List = getClusterList(ComponentOne);
                if (cluster1List.size() > 0)
                {
                    for (int i = 0; i < cluster1List.size(); i++)
                    {
                        graph.addEdge(cluster1List.get(i) + edgeSetKey + ContainingClusters.get(TargetClusterItr), cluster1List.get(i), ContainingClusters.get(TargetClusterItr));
                        mDataParser.getDerivedData().BuildNewClusterEdge(cluster1List.get(i) + edgeSetKey + ContainingClusters.get(TargetClusterItr), edgeSet);
                    }
                } else
                {
                    graph.addEdge(ComponentOne + edgeSetKey + ContainingClusters.get(TargetClusterItr), ComponentOne, ContainingClusters.get(TargetClusterItr));
                    mDataParser.getDerivedData().BuildNewClusterEdge(ComponentOne + edgeSetKey + ContainingClusters.get(TargetClusterItr), edgeSet);
                }

                LinkedList<String> cluster2List = getClusterList(ComponentTwo);
                if (cluster2List.size() > 0)
                {
                    for (int i = 0; i < cluster2List.size(); i++)
                    {
                        graph.addEdge(cluster2List.get(i) + edgeSetKey + ContainingClusters.get(TargetClusterItr), cluster2List.get(i), ContainingClusters.get(TargetClusterItr));
                        mDataParser.getDerivedData().BuildNewClusterEdge(cluster2List.get(i) + edgeSetKey + ContainingClusters.get(TargetClusterItr), edgeSet);
                    }
                } else
                {
                    graph.addEdge(ComponentTwo + edgeSetKey + ContainingClusters.get(TargetClusterItr), ComponentTwo, ContainingClusters.get(TargetClusterItr));
                    mDataParser.getDerivedData().BuildNewClusterEdge(ComponentTwo + edgeSetKey + ContainingClusters.get(TargetClusterItr), edgeSet);
                }
            }
        } /*            LinkedList<String> SourceList = new LinkedList<String>();
         LinkedList<String> InEdgeList = new LinkedList<String>();

         for (int i = 0; i < ContainingClusters.size(); i++)
         {
         LinkedList<NetworkElementApi> componentSet = mDataParser.getDerivedData().getNodeTable().get(ContainingClusters.get(i)).getNetworkElementSet();

         for (int j = 0; j < componentSet.size(); j++)
         {
         Collection<String> inEdges = mGraph.getInEdges(componentSet.get(j).getValue());
         if (inEdges != null)
         {
         String edgeSetKey = new String();
         for (int k = 0; k < inEdges.size(); k++)
         {
         String source = mGraph.getSource(inEdges.toArray()[k].toString());
         SourceList.add(source);

         edgeSetKey = edgeSetKey.concat(InEdgeList.get(k));
         }
         InEdgeList.addAll(inEdges);

         //Convert the Source list to clusterSourceLIst.
         LinkedList<String> ClusterSourceList = new LinkedList<String>();
         for (int k = 0; k < SourceList.size(); k++)
         {
         ClusterSourceList = getClusterList(SourceList.get(k));
         }

         for (int k = 0; k < ClusterSourceList.size(); k++)
         {
         String cluster = ContainingClusters.get(i);
         graph.addEdge(ClusterSourceList.get(k) + edgeSetKey + cluster, ClusterSourceList.get(k), cluster);
         mDataParser.getDerivedData().BuildNewClusterEdge(ClusterSourceList.get(k) + edgeSetKey + cluster, InEdgeList);
         }
         }
         }
         }*/ else
        {
            String edgeSetKey = new String();
            edgeSetKey = edgeSetKey.concat(bubble.getPaths().get(0).get(1).getValue());
            edgeSetKey = edgeSetKey.concat(bubble.getPaths().get(1).get(1).getValue());

            LinkedList<String> edgeSet = new LinkedList<String>();
            edgeSet.add(bubble.getPaths().get(0).get(1).getValue());
            edgeSet.add(bubble.getPaths().get(1).get(1).getValue());

            String ComponentOne = mGraph.getDest(bubble.getPaths().get(0).get(0).getValue());
            String ComponentTwo = mGraph.getDest(bubble.getPaths().get(1).get(0).getValue());

            LinkedList<String> cluster1List = getClusterList(ComponentOne);
            if (cluster1List.size() > 0)
            {
                for (int i = 0; i < cluster1List.size(); i++)
                {
                    graph.addEdge(cluster1List.get(i) + edgeSetKey + bubble.getTarget().getValue(), cluster1List.get(i), bubble.getTarget().getValue());
                    mDataParser.getDerivedData().BuildNewClusterEdge(cluster1List.get(i) + edgeSetKey + bubble.getTarget().getValue(), edgeSet);
                }
            } else
            {
                graph.addEdge(ComponentOne + edgeSetKey + bubble.getTarget().getValue(), ComponentOne, bubble.getTarget().getValue());
                mDataParser.getDerivedData().BuildNewClusterEdge(ComponentOne + edgeSetKey + bubble.getTarget().getValue(), edgeSet);
            }

            LinkedList<String> cluster2List = getClusterList(ComponentTwo);
            if (cluster2List.size() > 0)
            {
                for (int i = 0; i < cluster2List.size(); i++)
                {
                    graph.addEdge(cluster2List.get(i) + edgeSetKey + bubble.getTarget().getValue(), cluster2List.get(i), bubble.getTarget().getValue());
                    mDataParser.getDerivedData().BuildNewClusterEdge(cluster2List.get(i) + edgeSetKey + bubble.getTarget().getValue(), edgeSet);
                }
            } else
            {
                graph.addEdge(ComponentTwo + edgeSetKey + bubble.getTarget().getValue(), ComponentTwo, bubble.getTarget().getValue());
                mDataParser.getDerivedData().BuildNewClusterEdge(ComponentTwo + edgeSetKey + bubble.getTarget().getValue(), edgeSet);
            }
        }
    }

    private void LinkBubbleSourceToClusteredVertex(BubbleApi bubble, DirectedSparseMultigraph<String, String> graph)
    {
        String edgeSetKey = BubbleSource_EdgeSetKey.get(bubble.getSource());
        NetworkElementApi srcNEA = bubble.getSource();

        //If the Bubble Source, is contained in a Clustered Vertex, we use the clustered vertex instead.
        String src = bubble.getSource().getValue();
        boolean clusterTwoFlag = false; //We don't want to link the bubbleSource to clusterTwo.

        //VertexOneClusterMap takes an NetworkElementApi and returns the clustered-vertex that the NEA belongs to.
        //if the source belongs to a cluster as the first component, get the cluster.
        if (VertexOneClusterMap.containsKey(srcNEA))
        {
            src = VertexOneClusterMap.get(srcNEA);
            clusterTwoFlag = true;
        }
        //if the source belongs to a cluster as the second component, get the cluster.
        if (VertexTwoClusterMap.containsKey(srcNEA))
        {
            src = VertexTwoClusterMap.get(srcNEA);
            clusterTwoFlag = true;
        }

        //Get component One.
        NetworkElementApi NEA_One = mDataParser.getNodeTable().get(mGraph.getDest(bubble.getPaths().get(0).get(0).getValue()).toString());
        //Get Component Two.
        NetworkElementApi NEA_Two = mDataParser.getNodeTable().get(mGraph.getDest(bubble.getPaths().get(1).get(0).getValue()).toString());
        //If component One is contained in a cluster, get the cluster.
        String ClusteredVertexKey = VertexOneClusterMap.get(NEA_One);
        //If component Two is contained in a cluster, get the cluster.
        String ClusteredVertexKey_2 = VertexTwoClusterMap.get(NEA_Two);

        if (clusterTwoFlag)
        {
            if (ClusteredVertexKey_2 != null)
            {
                if (ClusteredVertexKey_2.compareTo(ClusteredVertexKey) != 0)
                {
                    if (GraphContainsEdge(graph, src, ClusteredVertexKey_2) == null)
                    {
                        //graph.addEdge(edgeSetKey, EdgeSource, ClusteredVertexKey);
                        NetworkClusterElementApi edgeSet = mDataParser.getDerivedData().getEdgeTable().get(edgeSetKey);

                        Collection<String> elements = new ArrayList<String>();
                        for (int elementItr = 0; elementItr < edgeSet.getNetworkElementSet().size(); elementItr++)
                        {
                            elements.add(edgeSet.getNetworkElementSet().get(elementItr).getValue());
                        }
                        //graph.addEdge(edgeSetKey, EdgeSource, ClusteredVertexKey_2);
                        if (ConfirmComponents(edgeSetKey, ClusteredVertexKey_2, graph))
                        {
                            mDataParser.getDerivedData().BuildNewClusterEdge(src + edgeSetKey + ClusteredVertexKey_2, elements);
                            graph.addEdge(src + edgeSetKey + ClusteredVertexKey_2, src, ClusteredVertexKey_2);
                        }
                    }
                }
            }
        }
        if (GraphContainsEdge(graph, src, ClusteredVertexKey) == null)
        {
            //graph.addEdge(edgeSetKey, EdgeSource, ClusteredVertexKey);
            NetworkClusterElementApi edgeSet = mDataParser.getDerivedData().getEdgeTable().get(edgeSetKey);

            Collection<String> elements = new ArrayList<String>();
            for (int elementItr = 0; elementItr < edgeSet.getNetworkElementSet().size(); elementItr++)
            {
                elements.add(edgeSet.getNetworkElementSet().get(elementItr).getValue());
            }

            if (ConfirmComponents(edgeSetKey, ClusteredVertexKey, graph))
            {
                mDataParser.getDerivedData().BuildNewClusterEdge(src + edgeSetKey + ClusteredVertexKey, elements);
                graph.addEdge(src + edgeSetKey + ClusteredVertexKey, src, ClusteredVertexKey);
            }

            //TODO: Else, I need to find another ClusteredVertex that will fullfill our requirement of containing all of the EdgeSet-Destinations...
        }

    }

    private boolean ConfirmComponents(String edgeSetKey, String ClusteredVertexKey, DirectedSparseMultigraph<String, String> graph)
    {
        NetworkClusterElementApi edgeSet = mDataParser.getDerivedData().getEdgeTable().get(edgeSetKey);

        LinkedList<String> ComponentDestinations = new LinkedList<String>();
        for (int i = 0; i < edgeSet.getElementCount(); i++)
        {
            NetworkElementApi element = edgeSet.getNetworkElementSet().get(i);

            ComponentDestinations.add(graph.getDest(element.getValue()));

        }

        NetworkClusterVertexApi ClusteredVertex = mDataParser.getDerivedData().getNodeTable().get((ClusteredVertexKey));

        LinkedList<String> ComponentsInCluster = new LinkedList<String>();
        for (int i = 0; i < ClusteredVertex.getElementCount(); i++)
        {
            ComponentsInCluster.add(ClusteredVertex.getNetworkElementSet().get(i).getValue());
        }


        return (ComponentsInCluster.containsAll(ComponentDestinations));


        //NetworkElementApi ComponentDestinationNEA = mDataParser.getNodeTable().get(ComponentDestinations.get(i));
            /*if (VertexOneClusterMap.containsKey(ComponentDestinationNEA))
         {
         String CompOneDestination_Cluster = VertexOneClusterMap.get(ComponentDestinationNEA);
         }
         if (VertexTwoClusterMap.containsKey(ComponentDestinationNEA))
         {
         String CompTwoDestination_Cluster = VertexTwoClusterMap.get(ComponentDestinationNEA);
         }*/

    }

    /**
     * It seems that JUNG's graph.FindEdge(Vertex, Vertex) function does not
     * work. So I had to write my own...
     */
    private String GraphContainsEdge(DirectedSparseMultigraph<String, String> graph, String V1, String V2)
    {
        if (!graph.containsVertex(V1) || !graph.containsVertex(V2))
        {
            //one of the veritces is not contained, return null.
            return (null);
        }
        Collection<String> outEdges = graph.getOutEdges(V1);
        for (int i = 0; i < outEdges.size(); i++)
        {
            String dest = graph.getDest(outEdges.toArray()[i].toString());
            if (dest.compareTo(V2) == 0)
            {
                //An edge exists between these two vertices.
                return (outEdges.toArray()[i].toString());
            }
        }
        // No edge exists, return null.
        return (null);
    }

    private void LinkClusteredVertexToBubbleTarget(BubbleApi bubble, DirectedSparseMultigraph<String, String> graph)
    {
        //Get the clustered-edge
        String edgeSetKey = BubbleTarget_EdgeSetKey.get(bubble.getTarget());
        NetworkElementApi destNEA = bubble.getTarget();

        //Get the target.
        String bubbleTarget = bubble.getTarget().getValue();

        //Determine if the bubble-target is contained in a Cluster Map.
        boolean clusterTwoFlag = false;
        if (VertexOneClusterMap.containsKey(destNEA))
        {
            bubbleTarget = VertexOneClusterMap.get(destNEA);
            clusterTwoFlag = true;
        }
        if (VertexTwoClusterMap.containsKey(destNEA))
        {
            bubbleTarget = VertexTwoClusterMap.get(destNEA);
            clusterTwoFlag = true;
        }

        //Get the NetworkElement of the first path.
        NetworkElementApi NEA_One = mDataParser.getNodeTable().get(mGraph.getSource(bubble.getPaths().get(0).get(1).getValue()).toString());
        //Get the NetworkElement of the second path.
        NetworkElementApi NEA_Two = mDataParser.getNodeTable().get(mGraph.getSource(bubble.getPaths().get(1).get(1).getValue()).toString());

        //Get the clusteredVertex of the first path NEA.
        String ClusteredVertexKey = VertexOneClusterMap.get(NEA_One);
        //Get the clusteredVertex of the second path NEA.
        String ClusteredVertexKey_2 = VertexTwoClusterMap.get(NEA_Two);

        /**
         * Essentially what we are doing here is getting some original
         * clustered-Edge which is used to connect a ClusteredVertex made from
         * the current bubble and the bubble's BubbleTarget.
         *
         */
        //If the bubbleTarget is contained in a cluster of a different bubble.
        if (clusterTwoFlag)
        {
            //If the bubbleTarget is in the second path of a cluster.
            if (ClusteredVertexKey_2 != null)
            {
                //Make sure the clusters are not the same...
                if (ClusteredVertexKey_2.compareTo(ClusteredVertexKey) != 0)
                {
                    //Determine if there is an edge between ClusterVertex2 and the bubbleTarget.
                    if (GraphContainsEdge(graph, ClusteredVertexKey_2, bubbleTarget) == null)
                    {
                        //graph.addEdge(edgeSetKey, EdgeSource, ClusteredVertexKey);
                        //Get the edgeSet for the edgeSetKey.
                        NetworkClusterElementApi edgeSet = mDataParser.getDerivedData().getEdgeTable().get(edgeSetKey);

                        //Reconstruct the edgeSet as a Collection of strings, necessary for the BuildNewClusterEdge function.
                        Collection<String> elements = new ArrayList<String>();
                        for (int elementItr = 0; elementItr < edgeSet.getNetworkElementSet().size(); elementItr++)
                        {
                            elements.add(edgeSet.getNetworkElementSet().get(elementItr).getValue());
                        }

                        //if (ConfirmComponents(edgeSetKey, ClusteredVertexKey_2, graph))
                        //{
                        //graph.addEdge(edgeSetKey, EdgeSource, ClusteredVertexKey_2);
                        mDataParser.getDerivedData().BuildNewClusterEdge(ClusteredVertexKey_2 + edgeSetKey + bubbleTarget, elements);
                        graph.addEdge(ClusteredVertexKey_2 + edgeSetKey + bubbleTarget, ClusteredVertexKey_2, bubbleTarget);
                        //}
                    }
                    //graph.addEdge(ClusteredVertexKey_2 + edgeSetKey + EdgeDest, ClusteredVertexKey_2, EdgeDest);
                }
            }
        }
        if (GraphContainsEdge(graph, ClusteredVertexKey, bubbleTarget) == null)
        {
            //graph.addEdge(edgeSetKey, EdgeSource, ClusteredVertexKey);
            NetworkClusterElementApi edgeSet = mDataParser.getDerivedData().getEdgeTable().get(edgeSetKey);

            Collection<String> elements = new ArrayList<String>();
            for (int elementItr = 0; elementItr < edgeSet.getNetworkElementSet().size(); elementItr++)
            {
                elements.add(edgeSet.getNetworkElementSet().get(elementItr).getValue());
            }

            //if (ConfirmComponents(edgeSetKey, ClusteredVertexKey, graph))
            //{

            mDataParser.getDerivedData().BuildNewClusterEdge(ClusteredVertexKey + edgeSetKey + bubbleTarget, elements);
            graph.addEdge(ClusteredVertexKey + edgeSetKey + bubbleTarget, ClusteredVertexKey, bubbleTarget);
            //}
        }
        //graph.addEdge(ClusteredVertexKey + edgeSetKey + EdgeDest, ClusteredVertexKey, EdgeDest);
    }

    /**
     * This is the case where a Network-Edge links a single component of a
     * bubble, to a non-bubble vertex. This is clusters to non-Clusters.
     *
     * @param graph
     */
    private void LinkClustersToNonClusters(DirectedSparseMultigraph<String, String> graph)
    {
        //Iterate all the vertices of graph.
        for (int i = 0; i < graph.getVertexCount(); i++)
        {
            //get the vertex "i".
            String vertex = graph.getVertices().toArray()[i].toString();

            //Confirm the nodeTable contains our vertex.
            if (mDataParser.getNodeTable().containsKey(vertex))
            {
                LinkedList<LinkedList<String>> triplet = new LinkedList<LinkedList<String>>();
                //Return the NetworkElement pertaining to the current vertex, which is stored in the DataParser.NodeTable.
                NetworkElementApi ClusterComponentOne = mDataParser.getNodeTable().get(vertex);

                //Determine if VertexOneClusterMap contains our vertex. If so, we can retrieve the clustered-vertex containing our "vertex".
                if (VertexOneClusterMap.containsKey(ClusterComponentOne))
                {
                    //Retrieve our clustered-vertex.
                    String ClusteredVertexOne = VertexOneClusterMap.get(ClusterComponentOne);

                    //we retrieve the outedges of our current vertex in graph.
                    Collection<String> ClusterComponentOutEdges = mGraph.getOutEdges(vertex);

                    //itereate the outEdges of current vertex.
                    for (int j = 0; j < ClusterComponentOutEdges.size(); j++)
                    {
                        //Get the edge.
                        String edge = ClusterComponentOutEdges.toArray()[j].toString();
                        //Get the "target" or destination of that edge.
                        String destination = mGraph.getDest(edge);
                        //Add an edge between our clustered vertex to our destination.

                        if (!VertexOneClusterMap.containsKey(mDataParser.getNodeTable().get(destination))
                                && !VertexTwoClusterMap.containsKey(mDataParser.getNodeTable().get(destination)))
                        {
                            LinkedList<String> tupleSet = new LinkedList<String>();
                            tupleSet.add(edge);
                            tupleSet.add(ClusteredVertexOne);
                            tupleSet.add(destination);
                            triplet.add(tupleSet);
                            //graph.addEdge(ClusteredVertexOne + edge + destination, ClusteredVertexOne, destination);
                        }
                    }
                    //remove the disconnected vertex.
                    graph.removeVertex(vertex);
                }

                NetworkElementApi NEA_Two = mDataParser.getNodeTable().get(vertex);
                if (VertexTwoClusterMap.containsKey(NEA_Two))
                {
                    String ClusteredVertexTwo = VertexTwoClusterMap.get(NEA_Two);
                    Collection<String> outEdges = mGraph.getOutEdges(vertex);
                    if (outEdges != null)
                    {
                        for (int j = 0; j < outEdges.size(); j++)
                        {
                            String edge = outEdges.toArray()[j].toString();
                            String destination = graph.getDest(edge);
                            if (!VertexOneClusterMap.containsKey(mDataParser.getNodeTable().get(destination))
                                    && !VertexTwoClusterMap.containsKey(mDataParser.getNodeTable().get(destination)))
                            {
                                LinkedList<String> tupleSet = new LinkedList<String>();
                                tupleSet.add(edge);
                                tupleSet.add(ClusteredVertexTwo);
                                tupleSet.add(destination);
                                triplet.add(tupleSet);
                            }
                        }
                        graph.removeVertex(vertex);
                    }
                }
                for (int tripletItr = 0; tripletItr < triplet.size(); tripletItr++)
                {
                    LinkedList<String> tuple = triplet.get(tripletItr);
                    graph.addEdge(tuple.get(0), tuple.get(1), tuple.get(2));
                }
            }
        }
    }

    private void ClustersToNonClusters(DirectedSparseMultigraph<String, String> newGraph)
    {
        Set<String> keySet = mDataParser.getDerivedData().getNodeTable().keySet();
        for (int i = 0; i < mDataParser.getDerivedData().getNodeTable().size(); i++)
        {
            NetworkClusterVertexApi Cluster = mDataParser.getDerivedData().getNodeTable().get(keySet.toArray()[i].toString());

            LinkedList<LinkedList<String>> triplet = new LinkedList<LinkedList<String>>();
            for (int j = 0; j < Cluster.getNetworkElementSet().size(); j++)
            {
                String C1_element = Cluster.getNetworkElementSet().get(j).getValue();
                Collection<String> outEdges = mGraph.getOutEdges(C1_element);

                for (int k = 0; k < outEdges.size(); k++)
                {
                    String edge = outEdges.toArray()[k].toString();
                    String dest = mGraph.getDest(edge);

                    boolean ignore = false;
                    for (int m = 0; m < mBubbleList.size(); m++)
                    {
                        if (mBubbleList.get(m).getTarget().getValue().compareTo(dest) == 0)
                        {
                            ignore = true;
                        }
                    }

                    if (!VertexOneClusterMap.containsKey(mDataParser.getNodeTable().get(dest))
                            && !VertexTwoClusterMap.containsKey(mDataParser.getNodeTable().get(dest))
                            && !ignore)
                    {
                        LinkedList<String> tupleSet = new LinkedList<String>();
                        tupleSet.add(edge);
                        tupleSet.add(Cluster.getValue());
                        tupleSet.add(dest);
                        triplet.add(tupleSet);
                        newGraph.removeVertex(C1_element);
                        //newGraph.removeEdge(edge);
                    }
                }
            }
            for (int tripletItr = 0; tripletItr < triplet.size(); tripletItr++)
            {
                LinkedList<String> tuple = triplet.get(tripletItr);
                if (this.GraphContainsEdge(newGraph, tuple.get(1), tuple.get(2)) == null)
                {
                    newGraph.addEdge( tuple.get(1)+tuple.get(0)+tuple.get(2), tuple.get(1), tuple.get(2));
                }
            }
        }
    }

    /**
     *    * This is the case where a Network-Edge links a non-bubble vertex to a
     * single component of a bubble. This is non-Clusters to clusters.
     *
     * @param graph
     */
    private void LinkNonClustersToClusters(DirectedSparseMultigraph<String, String> graph)
    {
        for (int i = 0; i < graph.getVertexCount(); i++)
        {
            String vertex = graph.getVertices().toArray()[i].toString();
            //get out degree edges.

            if (!VertexOneClusterMap.containsKey(mDataParser.getNodeTable().get(vertex))
                    && !VertexTwoClusterMap.containsKey(mDataParser.getNodeTable().get(vertex)))
            {
                Collection<String> outEdges = mGraph.getOutEdges(vertex);
                //Collection<String> edgeRemovalList = new LinkedList<String>();
                if (outEdges != null)
                {
                    for (int edgeItr = 0; edgeItr < outEdges.size(); edgeItr++)
                    {
                        String edge = outEdges.toArray()[edgeItr].toString();

                        //get destinations.
                        String destination = mGraph.getDest(edge);

                        //Confirm the destination is contained in a cluster.
                        NetworkElementApi destinationNea = mDataParser.getNodeTable().get(destination);
                        if (VertexOneClusterMap.containsKey(destinationNea))
                        {
                            //get clusteres containing destinations.
                            String ClusteredVertex = VertexOneClusterMap.get(destinationNea);
                            if (graph.findEdge(vertex, ClusteredVertex) == null)
                            {
                                //Remove the edge, so I can add it to be the link from vertex to ClusteredVertex.
                                graph.removeEdge(edge);
                                graph.removeVertex(destination);
                                //Add an edge between current vertex and cluster.
                                graph.addEdge(edge, vertex, ClusteredVertex);
                                //graph.addEdge(vertex + edge + ClusteredVertex, vertex, ClusteredVertex);
                            }
                        }
                        if (VertexTwoClusterMap.containsKey(destinationNea))
                        {
                            String ClusteredVertex = VertexTwoClusterMap.get(destinationNea);
                            if (graph.findEdge(vertex, ClusteredVertex) == null)
                            {
                                graph.removeEdge(edge);
                                graph.removeVertex(destination);
                                graph.addEdge(edge, vertex, ClusteredVertex);
                                //graph.addEdge(vertex + edge + ClusteredVertex, vertex, ClusteredVertex);
                            }
                        }
                    }
                }
            }
        }
    }

    private String BuildEdgeSetKey(LinkedList<String> edgeSet)
    {
        String edgeSetKey = new String();
        for (int i = 0; i < edgeSet.size(); i++)
        {
            edgeSetKey = edgeSetKey.concat(edgeSet.get(i));
        }
        return (edgeSetKey);
    }

    private void SourceToBubble(BubbleApi bubble, DirectedSparseMultigraph<String, String> newGraph)
    {
        String source = bubble.getSource().getValue();
        LinkedList<String> clusterList = getClusterList(source);
        if (bubble.getPaths().get(0).size() == 2 && bubble.getPaths().get(1).size() == 2)
        {
            if (clusterList.size() == 0)
            {
                LinkedList<String> edgeSet = new LinkedList<String>();
                edgeSet.add(bubble.getPaths().get(0).get(0).getValue());
                edgeSet.add(bubble.getPaths().get(1).get(0).getValue());

                String C1 = mGraph.getDest(bubble.getPaths().get(0).get(0).getValue());
                String C2 = mGraph.getDest(bubble.getPaths().get(1).get(0).getValue());
                String clusterVertex = C1.concat(C2);
                String edgeSetKey = this.BuildEdgeSetKey(edgeSet);
                if (mDataParser.getDerivedData().getNodeTable().containsKey(clusterVertex))
                {
                    newGraph.addEdge(source + edgeSetKey + clusterVertex, source, clusterVertex);
                    mDataParser.getDerivedData().BuildNewClusterEdge(source + edgeSetKey + clusterVertex, edgeSet);
                } else
                {
                    clusterVertex = C2.concat(C1);
                    if (mDataParser.getDerivedData().getNodeTable().containsKey(clusterVertex))
                    {
                        newGraph.addEdge(source + edgeSetKey + clusterVertex, source, clusterVertex);
                        mDataParser.getDerivedData().BuildNewClusterEdge(source + edgeSetKey + clusterVertex, edgeSet);
                    }
                }
            }
        }
    }

    private void BubbleToTarget(BubbleApi bubble, DirectedSparseMultigraph<String, String> newGraph)
    {
        String target = bubble.getTarget().getValue();
        LinkedList<String> clusterList = getClusterList(target);
        if (bubble.getPaths().get(0).size() == 2 && bubble.getPaths().get(1).size() == 2)
        {

            if (clusterList.size() == 0)
            {
                LinkedList<String> edgeSet = new LinkedList<String>();
                edgeSet.add(bubble.getPaths().get(0).get(1).getValue());
                edgeSet.add(bubble.getPaths().get(1).get(1).getValue());

                String C1 = mGraph.getSource(bubble.getPaths().get(0).get(1).getValue());
                String C2 = mGraph.getSource(bubble.getPaths().get(1).get(1).getValue());
                String clusterVertex = C1.concat(C2);
                String edgeSetKey = this.BuildEdgeSetKey(edgeSet);
                if (mDataParser.getDerivedData().getNodeTable().containsKey(clusterVertex))
                {
                    newGraph.addEdge(clusterVertex + edgeSetKey + target, clusterVertex, target);
                    mDataParser.getDerivedData().BuildNewClusterEdge(clusterVertex + edgeSetKey + target, edgeSet);
                } else
                {
                    clusterVertex = C2.concat(C1);
                    if (mDataParser.getDerivedData().getNodeTable().containsKey(clusterVertex))
                    {
                        newGraph.addEdge(clusterVertex + edgeSetKey + target, clusterVertex, target);
                        mDataParser.getDerivedData().BuildNewClusterEdge(clusterVertex + edgeSetKey + target, edgeSet);
                    }
                }
            }
        }
    }

    private void mGenerateGraphBtnActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_mGenerateGraphBtnActionPerformed
    {//GEN-HEADEREND:event_mGenerateGraphBtnActionPerformed
        DirectedSparseMultigraph<String, String> newGraph = new DirectedSparseMultigraph<String, String>();
        for (int i = 0; i < mGraph.getEdgeCount(); i++)
        {
            String edge = mGraph.getEdges().toArray()[i].toString();
            String src = mGraph.getSource(edge);
            String dest = mGraph.getDest(edge);

            boolean AddSrcEdgeDest = true;
            for (int j = 0; j < mBubbleList.size(); j++)
            {
                BubbleApi bubble = mBubbleList.get(j);

                //DO something about bubbles with un-equal path lengths.
                if (bubble.PathsEqualLength() && bubble.EdgeContainedInPaths(edge))
                {
                    AddSrcEdgeDest = false;
                }
                String dest1 = mGraph.getDest(bubble.getPaths().get(0).get(0).getValue());
                String dest2 = mGraph.getDest(bubble.getPaths().get(1).get(0).getValue());
                if ((dest1.compareTo(src) == 0)
                        || (dest2.compareTo(src) == 0))
                {
                    AddSrcEdgeDest = false;
                }
            }
            if (AddSrcEdgeDest)
            {
                newGraph.addEdge(edge, src, dest);
            }
        }

        //Build all of the Clustered-Vertices.
        for (int i = 0; i < mBubbleList.size(); i++)
        {
            BubbleApi bubble = mBubbleList.get(i);
            if (bubble.getPaths().get(0).size() == 2 && bubble.getPaths().get(1).size() == 2)
            {
                BuildClusteredVertex_Edge(bubble);
            }
        }

        /*for (int i = 0; i < mBubbleList.size(); i++)
         {
         BubbleApi bubble = mBubbleList.get(i);
         if (bubble.getPaths().get(0).size() == 2 && bubble.getPaths().get(1).size() == 2)
         {
         SourceToClusters(bubble, newGraph);
         ClustersToTarget(bubble, newGraph);
         //LinkBubbleSourceToClusteredVertex(bubble, newGraph);
         //LinkClusteredVertexToBubbleTarget(bubble, newGraph);

         }
         }*/

        Set<String> keySet = mDataParser.getDerivedData().getNodeTable().keySet();
        for (int i = 0; i < mDataParser.getDerivedData().getNodeTable().size(); i++)
        {
            NetworkClusterVertexApi Cluster = mDataParser.getDerivedData().getNodeTable().get(keySet.toArray()[i].toString());
            for (int k = 0; k < mDataParser.getDerivedData().getNodeTable().size(); k++)
            {
                NetworkClusterVertexApi otherCluster = mDataParser.getDerivedData().getNodeTable().get(keySet.toArray()[k].toString());

                LinkedList<String> edgeSet = new LinkedList<String>();
                for (int j = 0; j < Cluster.getNetworkElementSet().size(); j++)
                {
                    String C1_element = Cluster.getNetworkElementSet().get(j).getValue();

                    for (int m = 0; m < otherCluster.getNetworkElementSet().size(); m++)
                    {
                        String C2_element = otherCluster.getNetworkElementSet().get(m).getValue();

                        String edge = GraphContainsEdge(mGraph, C1_element, C2_element);
                        if (edge != null)
                        {
                            if (!edgeSet.contains(edge))
                            {
                                edgeSet.add(edge);
                            }
                        }
                    }
                }
                if (edgeSet.size() > 0)
                {
                    String edgeSetKey = BuildEdgeSetKey(edgeSet);
                    mDataParser.getDerivedData().BuildNewClusterEdge(Cluster.getValue() + edgeSetKey + otherCluster.getValue(), edgeSet);
                    newGraph.addEdge(Cluster.getValue() + edgeSetKey + otherCluster.getValue(), Cluster.getValue(), otherCluster.getValue());
                }
            }

        }

        for (int i = 0; i < mBubbleList.size(); i++)
        {
            BubbleApi bubble = mBubbleList.get(i);
            SourceToBubble(bubble, newGraph);
            BubbleToTarget(bubble, newGraph);
        }
        //LinkClustersToNonClusters(newGraph);
        ClustersToNonClusters(newGraph);
        LinkNonClustersToClusters(newGraph);

        /*
         Set<String> NodeRemovalList = new HashSet<String>();
         HashMap<String, Collection<String>> PsuedoClusteredVertexTable = new HashMap<String, Collection<String>>();

         for (int i = 0; i < mBubbleList.size(); i++)
         {
         //Get the two paths contained in the bubble.
         List<NetworkElementApi> PathOne = mBubbleList.get(i).getPaths().get(0);
         List<NetworkElementApi> PathTwo = mBubbleList.get(i).getPaths().get(1);

         //Make a combined set of the two nodes in the bubble.
         Collection<String> combined = new ArrayList<String>();
         String NodeOne = mGraph.getDest(PathOne.get(0).getValue());
         String NodeTwo = mGraph.getDest(PathTwo.get(0).getValue());
         combined.add(NodeOne);
         combined.add(NodeTwo);






             
         //I can't just collapse, b/c sometimes a node needs to be in two different "Collapsed" nodes. So it doesn't know which one to put in...
         //DirectedSparseMultigraph inGraph = mGraph;
         //DirectedSparseMultigraph<String, String> clusterGraph = (DirectedSparseMultigraph<String, String>) mNVV.getGraphCollapser().getClusterGraph(inGraph, combined);
         //DirectedSparseMultigraph g = (DirectedSparseMultigraph) mNVV.getGraphCollapser().collapse(mGraph, clusterGraph);

         //mNVV.getRenderContext().getParallelEdgeIndexFunction().reset();
         //mGraph = g;
         //mNVV.getGraphLayout().setGraph(g);

         //mNVV.repaint();

         //Create our new clustered node, the combination of Nodes One and Two.
         String newClusterNodeKey = NodeOne + NodeTwo;

         //Instantiate our new clustered Node.
         mDataParser.getDerivedData().BuildNewClusterNode(newClusterNodeKey, combined);
         PsuedoClusteredVertexTable.put(newClusterNodeKey, combined);

         // Here we are going to combine the edges in the "bubble paths" to
         // make our clustered edge.

         ArrayList<String> inPathEdges = new ArrayList<String>();
         //Instantiate our new string which will be the identifier for our clustered edge.
         //Assign values for our clustered edge.
         String newInClusterEdgeKey = PathOne.get(0).getValue();
         newInClusterEdgeKey = newInClusterEdgeKey.concat(PathTwo.get(0).getValue());

         //make the combined set of edges.
         inPathEdges.add(PathOne.get(0).getValue());
         inPathEdges.add(PathTwo.get(0).getValue());

         //Instantiate our clustered edge.
         mDataParser.getDerivedData().BuildNewClusterEdge(newInClusterEdgeKey, inPathEdges);

         //Link our bubble source, to our new bubble node...
         String bubbleSource = mBubbleList.get(i).getSource().getValue();
         newGraph.addEdge(newInClusterEdgeKey, bubbleSource, newClusterNodeKey);

         //  Next we will handle linking In-Edges that are not in our bubble.
         ArrayList<String> inEdges = new ArrayList<String>();
         //This is the set of ALL inEdges, including in-bubble-edges.
         Collection<String> inEdges1 = mGraph.getInEdges(NodeOne);
         Collection<String> inEdges2 = mGraph.getInEdges(NodeTwo);
         inEdges.addAll(inEdges1);
         inEdges.addAll(inEdges2);

         //Iterate the inEdges.
         for (int j = 0; j < inEdges.size(); j++)
         {
         String edge = inEdges.toArray()[j].toString();
         //When the current In-Edge is NOT in the bubble...


         if (!inPathEdges.contains(edge))
         {
         //Get the original sources, and link them to our new ClusterNode (key).
         String nonPathSource = mGraph.getSource(edge);
         newGraph.addEdge(nonPathSource + edge + newClusterNodeKey, nonPathSource, newClusterNodeKey);
         } else
         {

         //Check combine: predecessors.
         String pathSource = mGraph.getSource(edge);
         //Iterate PsuedoClusteredVertexTable, find out if the "collection" of some node contains our source.
         for (int k = 0; k < PsuedoClusteredVertexTable.keySet().size(); k++)
         {
         String ClusteredVertex = PsuedoClusteredVertexTable.keySet().toArray()[k].toString();
         if (PsuedoClusteredVertexTable.get(ClusteredVertex).contains(pathSource))
         {
         newGraph.addEdge(ClusteredVertex + edge + newClusterNodeKey, ClusteredVertex, newClusterNodeKey);
         }
         }
         }
         }
         //If the successors or predecessors are contained in a Clustered Node, link that clustered node to this node.

         //Instantiate our new string which will be the identifier for our clustered edge.
         //Assign values for our clustered edge.
         String newOutClusterEdgeKey = PathOne.get(1).getValue();
         newOutClusterEdgeKey = newOutClusterEdgeKey.concat(PathTwo.get(1).getValue());

         //make the combined set of edges.
         ArrayList<String> outPathEdges = new ArrayList<String>();
         outPathEdges.add(PathOne.get(1).getValue());
         outPathEdges.add(PathTwo.get(1).getValue());

         //Instantiate our clustered edge.
         mDataParser.getDerivedData().BuildNewClusterEdge(newOutClusterEdgeKey, outPathEdges);

         //Link our bubble source, to our new bubble node...
         String bubbleTarget = mBubbleList.get(i).getTarget().getValue();
         newGraph.addEdge(newOutClusterEdgeKey, newClusterNodeKey, bubbleTarget);

         //Get the outEdges for the nodes we are going to replace.
         ArrayList<String> outEdges = new ArrayList<String>();
         Collection<String> outEdges1 = mGraph.getOutEdges(NodeOne);
         Collection<String> outEdges2 = mGraph.getOutEdges(NodeTwo);
         outEdges.addAll(outEdges1);
         outEdges.addAll(outEdges2);

         //Iterate the outEdges.
         for (int j = 0; j < outEdges.size(); j++)
         {
         String edge = outEdges.toArray()[j].toString();
         //When the current Out-Edge is NOT in the bubble.
         if (!outPathEdges.contains(edge))
         {
         //Get the original destinations, and link our new ClusterNode (Key) to them.
         String nonPathDest = mGraph.getDest(edge);
         newGraph.addEdge(newClusterNodeKey + edge + nonPathDest, newClusterNodeKey, nonPathDest);
         } else
         {
         //  This Else, checks and builds links between Clustered Nodes,
         //  by checking which "standard" nodes are now contained in a
         //  clustered node. Then it builds the link accordingly.

         //Check combine: successors.
         String pathDest = mGraph.getDest(edge);
         //Iterate PsuedoClusteredVertexTable, find out of the "collection" of some node contains our source.
         for (int k = 0; k < PsuedoClusteredVertexTable.keySet().size(); k++)
         {
         String ClusteredVertex = PsuedoClusteredVertexTable.keySet().toArray()[k].toString();
         if (PsuedoClusteredVertexTable.get(ClusteredVertex).contains(pathDest))
         {
         newGraph.addEdge(newClusterNodeKey + edge + ClusteredVertex, newClusterNodeKey, ClusteredVertex);
         }
         }
         }

         }

         NodeRemovalList.add(NodeOne);
         NodeRemovalList.add(NodeTwo);
         }

         for (int i = 0; i < NodeRemovalList.size(); i++)
         {
         String node = NodeRemovalList.toArray()[i].toString();
         newGraph.removeVertex(node);
         }
        
         */

        NetworkDisplayTopComponent ndtc = new NetworkDisplayTopComponent(newGraph, DisplayType.MIXED);
        ndtc.open();
        ndtc.setName("Mixed Display");
    }//GEN-LAST:event_mGenerateGraphBtnActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton CalculateBubblesjbtn;
    private javax.swing.JScrollPane mBeanTreeView;
    private javax.swing.JButton mGenerateGraphBtn;
    private javax.swing.JTextField mRootTextField;
    // End of variables declaration//GEN-END:variables

    @Override
    public void componentOpened()
    {
        mDataParser = Lookup.getDefault().lookup(DataParser.class);
        ((NetworkVVDisplay) (WindowManager.getDefault().findTopComponent("NetworkDisplayTopComponent"))).RebroadcastNetworkVisualizationViewer();
        if (mDataParser.hasData())
        {
            this.RefreshContents();
        }
    }

    private void CalculateBubbles()
    {
        //Get all out degree 2+ vertices from the graph.
        ArrayList<String> OutDegree2Vertices = new ArrayList<String>(); //Source list.
        for (int i = 0; i < mGraph.getVertexCount(); i++)
        {
            String vertex = mGraph.getVertices().toArray()[i].toString();
            if (mGraph.outDegree(vertex) > 1 && !vertex.matches(mRootTextField.getText()))
            {
                OutDegree2Vertices.add(vertex);
            }
        }

        //Get all In Degree 2+ vertices from the graph.
        ArrayList<String> InDegree2Vertices = new ArrayList<String>(); //Target list.
        for (int i = 0; i < mGraph.getVertexCount(); i++)
        {
            String vertex = mGraph.getVertices().toArray()[i].toString();
            if (mGraph.inDegree(vertex) > 1)
            {
                InDegree2Vertices.add(vertex);
            }
        }

        //Go through the lists, identify if there is a path from the Source list, to the target list.
        //If there is no path, we can ignore it.
        DijkstraShortestPath<String, String> dsp = new DijkstraShortestPath<String, String>(mGraph);
        dsp.setMaxDistance(5);

        List<List<String>> PathList = new ArrayList<List<String>>();

        for (int i = 0; i < OutDegree2Vertices.size(); i++)
        {

            String source = OutDegree2Vertices.get(i).toString();
            for (int j = 0; j < InDegree2Vertices.size(); j++)
            {
                String target = InDegree2Vertices.get(j).toString();
                List<String> path = dsp.getPath(source, target);
                if (!path.isEmpty())
                {
                    PathList.add(path);
                }
            }
        }

        //The PathList stores all the combos between our source and target vertices,
        // and shows that there exists a path between the two.
        //Now we will will iterate that PathList, and remove any pair of source and target
        //vertices that do not contain multiple paths between the two.


        for (int i = 0; i < PathList.size(); i++)
        {
            //Get the Source Vertex.
            String FirstEdge = PathList.get(i).get(0).toString();
            NetworkElementApi SrcVertex = mDataParser.getNodeTable().get(mGraph.getSource(FirstEdge));
            //Get the target vertex.
            String LastEdge = PathList.get(i).get(PathList.get(i).size() - 1);
            NetworkElementApi TgtVertex = mDataParser.getNodeTable().get(mGraph.getDest(LastEdge));

            BubbleModel bubble = new BubbleModel();
            bubble.setSource(SrcVertex);
            bubble.setTarget(TgtVertex);


            //List<List<NetworkElementApi>> allPathsBetweenNodes = AllPathDetector.getAllUniqePathsBetweenNodes(mDataParser.getGraph(), SrcVertex, TgtVertex, 5);
            AllPathDetector<String, String> PathDetector = new AllPathDetector<String, String>();
            List<List<String>> allPathsBetweenNodes = PathDetector.getAllUniqePathsBetweenNodes(mGraph, SrcVertex.getValue(), TgtVertex.getValue(), 2);


            /**
             * For this next part, we are essentially converting the path of
             * strings, to the path of NetworkElements which are contained in
             * the data tables of the DataParser.
             */
            if (allPathsBetweenNodes.size() > 1)
            {
                //This is the NetworkElement Path list.
                List<List<NetworkElementApi>> NEPathList = new ArrayList<List<NetworkElementApi>>();

                //We iterate through all the paths between our two current nodes.
                for (int pathItr = 0; pathItr < allPathsBetweenNodes.size(); pathItr++)
                {
                    NEPathList.add(new ArrayList<NetworkElementApi>());
                    //For each edge in our current path...
                    for (int edgeItr = 0; edgeItr < allPathsBetweenNodes.get(pathItr).size(); edgeItr++)
                    {
                        //We get the last path of the NetworkElement, and add the edge of the current path.
                        NEPathList.get(NEPathList.size() - 1).add(mDataParser.getEdgeTable().get(allPathsBetweenNodes.get(pathItr).get(edgeItr)));
                    }
                }
                //Next we want to identify distinct paths, or unique paths, from our allPathsBetweenNodes.
                for (int j = 0; j < NEPathList.size(); j++)
                {
                    bubble.addPath(NEPathList.get(j));
                    //mBubbleList.add(NEPathList.get(j));
                }
                mBubbleList.add(bubble);
            }
        }
        this.RefreshContents();
    }
    private List<BubbleApi> mBubbleList = new ArrayList<BubbleApi>();

    @Override
    public void ClearContents()
    {
        try
        {
            this.getExplorerManager().getRootContext().destroy();
        } catch (IOException ex)
        {
            Exceptions.printStackTrace(ex);
        }
    }

    @Override
    public void RefreshContents()
    {
        if (mDataParser.hasData())
        {
            Node trueRoot = new AbstractNode(Children.create(new BubbleNodeFactory(mBubbleList), true));
            mgr.setRootContext(trueRoot);
            mgr.getRootContext().setDisplayName("Bubbles: " + mBubbleList.size());

        } else
        {
            AbstractNode EmptyNode = new AbstractNode(Children.LEAF);
            EmptyNode.setName("File not loaded.");
            mgr.setRootContext(EmptyNode);
        }
    }

    @Override
    public void componentClosed()
    {
        try
        {
            mgr.getRootContext().destroy();
        } catch (IOException ex)
        {
            Exceptions.printStackTrace(ex);
        }
    }

    @Override
    public ExplorerManager getExplorerManager()
    {
        return (mgr);
    }

    void writeProperties(java.util.Properties p)
    {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p)
    {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }

    @Override
    public void UpdateCurrentVV(NetworkVisualizationViewer currentVV, DisplayType type)
    {
        if (mDataParser.hasData())
        {
            mNVV = currentVV;
            mDisplayTypeFlag = type;
            mGraph = (DirectedSparseMultigraph<String, String>) mNVV.getGraphLayout().getGraph();
            //em = ((NodeViewerTopComponentExtension) (WindowManager.getDefault().findTopComponent("BubbleViewerTopComponent"))).getExplorerManager();
            mNVV.AddChangeListenerToExplorerManager(this.getExplorerManager());
            this.getExplorerManager().addPropertyChangeListener(mNVV);
            if (type == DisplayType.STEPBASED)
            {
            }
            if (type == DisplayType.NETWORK)
            {
            }
        } else
        {
            this.close();
        }
    }
}
