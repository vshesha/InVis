package Transformers;

import GuiElements.RangeSlider;
import edu.uci.ics.jung.algorithms.cluster.WeakComponentClusterer;
import edu.uci.ics.jung.algorithms.shortestpath.DijkstraShortestPath;
import edu.uci.ics.jung.graph.DirectedSparseMultigraph;
import edu.uci.ics.jung.visualization.decorators.ToStringLabeller;
import invis.gl.MDP.MDPScorer;
import invis.gl.NetworkVisualizationViewer.NetworkVisualizationViewer;
import invis.gl.Transformers.edgePainter;
import invis.gl.Transformers.vertexPainter;
import invis.gl.dataprocessor.DataParser;
import invis.gl.graphvisualapi.NetworkDisplayApi.DisplayType;
import invis.gl.networkapi.AllPathDetector;
import invis.gl.networkapi.NetworkVVDisplay;
import invis.gl.networkapi.VisualEditorTopComponentExtension;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.explorer.ExplorerManager;
import org.openide.util.Exceptions;
import org.openide.util.Lookup;
import org.openide.util.NbBundle.Messages;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(dtd = "-//Transformers//MDP//EN",
autostore = false)
@TopComponent.Description(preferredID = "MDPTopComponent",
//iconBase="SET/PATH/TO/ICON/HERE", 
persistenceType = TopComponent.PERSISTENCE_NEVER)
@TopComponent.Registration(mode = "leftSlidingSide", openAtStartup = false)
@ActionID(category = "Window", id = "Transformers.MDPTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(displayName = "#CTL_MDPAction",
preferredID = "MDPTopComponent")
@Messages(
{
    "CTL_MDPAction=MDP Window",
    "CTL_MDPTopComponent=MDP Window",
    "HINT_MDPTopComponent=This is a MDP window"
})
public final class MDPTopComponent extends VisualEditorTopComponentExtension
{

    //private DataParser mDataParser;
    private HashMap<String, String> hintMap;
    //private NetworkVisualizationViewer mNVV;
    private DirectedSparseMultigraph<String, String> mGraph;

    public MDPTopComponent()
    {
        initComponents();
        setName(Bundle.CTL_MDPTopComponent());
        setToolTipText(Bundle.HINT_MDPTopComponent());

        NetworkVVDisplay ndtc = (NetworkVVDisplay) WindowManager.getDefault().findTopComponent("NetworkDisplayTopComponent");
        if (ndtc != null)
        {
            mNVV = ndtc.getNVV();
            if (mNVV != null)
            {
                mGraph = (DirectedSparseMultigraph<String, String>) mNVV.getGraphLayout().getGraph();
            }
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        mMdpCalculateButton = new javax.swing.JButton();
        GoalPathNodesSelector = new javax.swing.JButton();
        HintFactoryjButton = new javax.swing.JButton();
        FrequencyFilterjLabel3 = new javax.swing.JLabel();
        mdpValueSlider = new GuiElements.RangeSlider();
        mRemoveLowMDPValueButton = new javax.swing.JButton();
        inDegreeFreqCalcbutton = new javax.swing.JButton();
        StrategyReduceButton = new javax.swing.JButton();
        mGoalShortestPathsButton = new javax.swing.JButton();
        mRootText = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        mBubbleDetectorjbtn = new javax.swing.JButton();
        jSeparator1 = new javax.swing.JSeparator();

        setAutoscrolls(true);

        org.openide.awt.Mnemonics.setLocalizedText(mMdpCalculateButton, org.openide.util.NbBundle.getMessage(MDPTopComponent.class, "MDPTopComponent.mMdpCalculateButton.text")); // NOI18N
        mMdpCalculateButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                mMdpCalculateButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(GoalPathNodesSelector, org.openide.util.NbBundle.getMessage(MDPTopComponent.class, "MDPTopComponent.GoalPathNodesSelector.text")); // NOI18N
        GoalPathNodesSelector.setToolTipText(org.openide.util.NbBundle.getMessage(MDPTopComponent.class, "MDPTopComponent.GoalPathNodesSelector.toolTipText")); // NOI18N
        GoalPathNodesSelector.setEnabled(false);
        GoalPathNodesSelector.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                GoalPathNodesSelectorActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(HintFactoryjButton, org.openide.util.NbBundle.getMessage(MDPTopComponent.class, "MDPTopComponent.HintFactoryjButton.text")); // NOI18N
        HintFactoryjButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                HintFactoryjButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(FrequencyFilterjLabel3, org.openide.util.NbBundle.getMessage(MDPTopComponent.class, "MDPTopComponent.FrequencyFilterjLabel3.text")); // NOI18N
        FrequencyFilterjLabel3.setToolTipText(org.openide.util.NbBundle.getMessage(MDPTopComponent.class, "MDPTopComponent.FrequencyFilterjLabel3.toolTipText")); // NOI18N

        mdpValueSlider.setPaintLabels(true);
        mdpValueSlider.setPaintTicks(true);
        mdpValueSlider.setToolTipText(org.openide.util.NbBundle.getMessage(MDPTopComponent.class, "MDPTopComponent.mdpValueSlider.toolTipText")); // NOI18N
        mdpValueSlider.setValue(0);
        mdpValueSlider.setUpperValue(100);

        org.openide.awt.Mnemonics.setLocalizedText(mRemoveLowMDPValueButton, org.openide.util.NbBundle.getMessage(MDPTopComponent.class, "MDPTopComponent.mRemoveLowMDPValueButton.text")); // NOI18N
        mRemoveLowMDPValueButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                mRemoveLowMDPValueButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(inDegreeFreqCalcbutton, org.openide.util.NbBundle.getMessage(MDPTopComponent.class, "MDPTopComponent.inDegreeFreqCalcbutton.text")); // NOI18N
        inDegreeFreqCalcbutton.setEnabled(false);
        inDegreeFreqCalcbutton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                inDegreeFreqCalcbuttonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(StrategyReduceButton, org.openide.util.NbBundle.getMessage(MDPTopComponent.class, "MDPTopComponent.StrategyReduceButton.text")); // NOI18N
        StrategyReduceButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                StrategyReduceButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(mGoalShortestPathsButton, org.openide.util.NbBundle.getMessage(MDPTopComponent.class, "MDPTopComponent.mGoalShortestPathsButton.text")); // NOI18N
        mGoalShortestPathsButton.setEnabled(false);
        mGoalShortestPathsButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                mGoalShortestPathsButtonActionPerformed(evt);
            }
        });

        mRootText.setText(org.openide.util.NbBundle.getMessage(MDPTopComponent.class, "MDPTopComponent.mRootText.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(MDPTopComponent.class, "MDPTopComponent.jLabel1.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(mBubbleDetectorjbtn, org.openide.util.NbBundle.getMessage(MDPTopComponent.class, "MDPTopComponent.mBubbleDetectorjbtn.text")); // NOI18N
        mBubbleDetectorjbtn.setToolTipText(org.openide.util.NbBundle.getMessage(MDPTopComponent.class, "MDPTopComponent.mBubbleDetectorjbtn.toolTipText")); // NOI18N
        mBubbleDetectorjbtn.setEnabled(false);
        mBubbleDetectorjbtn.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                mBubbleDetectorjbtnActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSeparator1, javax.swing.GroupLayout.Alignment.TRAILING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(FrequencyFilterjLabel3)
                            .addComponent(mMdpCalculateButton))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(mdpValueSlider, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(15, 15, 15)
                                .addComponent(GoalPathNodesSelector))))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(inDegreeFreqCalcbutton)
                            .addComponent(StrategyReduceButton))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(mGoalShortestPathsButton)
                            .addComponent(mBubbleDetectorjbtn)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(mRootText))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(HintFactoryjButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(mRemoveLowMDPValueButton)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(mdpValueSlider, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(FrequencyFilterjLabel3)
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(mMdpCalculateButton)
                            .addComponent(GoalPathNodesSelector))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(mRemoveLowMDPValueButton)
                    .addComponent(HintFactoryjButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 4, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(3, 3, 3)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(inDegreeFreqCalcbutton)
                    .addComponent(mGoalShortestPathsButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(StrategyReduceButton)
                    .addComponent(mBubbleDetectorjbtn))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(mRootText, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void CalculateMDPValues()
    {
        if (!mDataParser.DataContainsGoalStates() || !mDataParser.DataContainsErrorStates())
        {
            JOptionPane.showMessageDialog(new JFrame(), "Warning: Errors and Goals are necessary for calculating MDP-Values.\n"
                    + "Load data that has optional data fields, ERROR and GOAL.");
        } else
        {
            this.mdpValueSlider.setEnabled(true);
            this.GoalPathNodesSelector.setEnabled(true);
            this.GoalPathNodesSelector.setToolTipText("Click to select all nodes that are on paths to the goal.");
            //this.mdpValueSlider.setToolTipText("Slide the sliders to adjust the range of MDP-values to view. Blue is the low value, Red is the high.");

            /*
             MinimumSpanningForest2<String, String> prim =
             new MinimumSpanningForest2<String, String>(mDataParser.getGraph(),
             new DelegateForest<String, String>(), DelegateTree.<String, String>getFactory(),
             new ConstantTransformer(1.0));

             Forest<String,String> tree = prim.getForest();*/

            MDPScorer<String, String> mdpScorer = new MDPScorer<String, String>(mGraph,
                    //MDPScorer mdpScorer = new MDPScorer(tree,
                    new FrequencyTransformer(mDataParser.getEdgeTable()),
                    new ToStringLabeller<String>(),
                    new StandardRewardTransformer(mDataParser.getEdgeTable()));
            mdpScorer.setMaxIterations(50);
            mdpScorer.evaluate();

            for (int i = 0; i < mGraph.getVertexCount(); i++)
            {
                String nodeKey = mGraph.getVertices().toArray()[i].toString();
                double val = mdpScorer.getOutputValue(nodeKey);
                mDataParser.getNodeTable().get(nodeKey).setMdpValue(val);

                if (mDataParser.getNodeTable().get(nodeKey).getGoalValue())
                {
                    mDataParser.getNodeTable().get(nodeKey).setMdpValue(100.0);
                }

                //Handle the assignment of MDP values of edges. 
                //Since we get the value directly from the node which just had it's
                //value assigned we accomodate the case for the goal nodes.
                Collection<String> inEdges = mGraph.getInEdges(nodeKey);
                for (int edgeIndex = 0; edgeIndex < inEdges.size(); edgeIndex++)
                {
                    mDataParser.getEdgeTable().get(inEdges.toArray()[edgeIndex].toString()).setMdpValue(
                            mDataParser.getNodeTable().get(nodeKey).getMDPValue());
                }

                //TODO: Should probably impelemnt an interface on the mdpScorer or on the EdgeRewardTransformer
                //but don't want to make it uncompatible with mike's work. Setting max value
                //if (mDataParser.getNodeTable().get(nodeKey).getGoalValue())
                //
                //{
                //    mDataParser.getNodeTable().get(nodeKey).setMdpValue(100.0);
                //}
                //}
            }
        }
    }

    private void mMdpCalculateButtonActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_mMdpCalculateButtonActionPerformed
    {//GEN-HEADEREND:event_mMdpCalculateButtonActionPerformed
        this.CalculateMDPValues();
    }//GEN-LAST:event_mMdpCalculateButtonActionPerformed

    private void GoalPathNodesSelectorActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_GoalPathNodesSelectorActionPerformed
    {//GEN-HEADEREND:event_GoalPathNodesSelectorActionPerformed

        mNVV.getPickedVertexState().clear();
        for (int i = 0; i < mGraph.getVertices().size(); i++)
        {
            String vertex = mGraph.getVertices().toArray()[i].toString();
            if (mDataParser.getNodeTable().get(vertex).getMDPValue() > 0.1f
                    || (mDataParser.getNodeTable().get(vertex).getMDPValue() == Double.MIN_VALUE && //This line and the one below it.
                    mDataParser.getNodeTable().get(vertex).getGoalValue())) // Handle the selection of goal nodes.
            {
                mNVV.getPickedVertexState().pick(vertex, true);
                mDataParser.getNodeTable().get(vertex).setSelected(true);
            }
        }
        mNVV.getRenderer().render(mNVV.getRenderContext(), mNVV.getGraphLayout());
        mNVV.repaint();
        this.revalidate();
    }//GEN-LAST:event_GoalPathNodesSelectorActionPerformed
    public void InitializeMdpValueSlider()
    {
        this.mdpValueSlider.setEnabled(false);
        this.mdpValueSlider.setToolTipText("Use the MDP button to calculate MDP-Values if you want to filter on them.");
        this.mdpValueSlider.setMinimum(0);
        this.mdpValueSlider.setMaximum(100); //TODO: Dynamically find the max value of the MDP values.
        this.mdpValueSlider.setValue(0);
        this.mdpValueSlider.setUpperValue(100); //TODO: Dynamically find the max value of the MDP values.
        if (this.mdpValueSlider.getMaximum() > 10)
        {
            this.mdpValueSlider.setMajorTickSpacing(this.mdpValueSlider.getMaximum() / 10);
        } else
        {
            this.mdpValueSlider.setMajorTickSpacing(this.mdpValueSlider.getMaximum() / 2);
        }
        if (mDataParser.hasData())
        {
            ((vertexPainter) mNVV.getRenderContext().getVertexFillPaintTransformer()).setMDPThreshold(mdpValueSlider.getValue(), mdpValueSlider.getUpperValue());
            ((edgePainter) mNVV.getRenderContext().getEdgeDrawPaintTransformer()).setMDPThreshold(mdpValueSlider.getValue(), mdpValueSlider.getUpperValue());
        }
    }

    private void buildMDPValueSlider()
    {
        this.InitializeMdpValueSlider();
        mdpValueSlider.addChangeListener(new ChangeListener()
        {
            @Override
            public void stateChanged(ChangeEvent e)
            {
                RangeSlider source = (RangeSlider) e.getSource();
                if (!source.getValueIsAdjusting())
                {
                    if (mDataParser.hasData())
                    {
                        ((vertexPainter) mNVV.getRenderContext().getVertexFillPaintTransformer()).setMDPThreshold(mdpValueSlider.getValue(), mdpValueSlider.getUpperValue());
                        ((edgePainter) mNVV.getRenderContext().getEdgeDrawPaintTransformer()).setMDPThreshold(mdpValueSlider.getValue(), mdpValueSlider.getUpperValue());
                        mNVV.repaint();
                    }
                }
            }
        });
    }

    private String GetHighestMdpValueSuccessor(String CurrentVertex)
    {
        Collection<String> successors = mGraph.getSuccessors(CurrentVertex);
        Double maxMdpValue = Double.MIN_VALUE;
        String maxMdpValueVertex = null;
        if (successors.size() > 0)
        {
            for (int i = 0; i < successors.size(); i++)
            {
                if (maxMdpValue < mDataParser.getNodeTable().get(successors.toArray()[i].toString()).getMDPValue())
                {
                    maxMdpValue = mDataParser.getNodeTable().get(successors.toArray()[i].toString()).getMDPValue();
                    maxMdpValueVertex = successors.toArray()[i].toString();
                }
            }
            return maxMdpValueVertex;
        } else
        {
            return ("");
        }
    }
    private void HintFactoryjButtonActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_HintFactoryjButtonActionPerformed
    {//GEN-HEADEREND:event_HintFactoryjButtonActionPerformed
        hintMap = new HashMap<String, String>();
        for (int i = 0; i < mGraph.getVertices().size(); i++)
        {
            String currentState = mGraph.getVertices().toArray()[i].toString();

            if (mGraph.getSuccessorCount(currentState) > 0) // If there are no children, it can't have a hint.
            {
                String HintTarget = this.GetHighestMdpValueSuccessor(currentState);

                if (HintTarget != null)
                {
                    //TODO: States that have no action, have no HintTarget, need to handle
                    //this as a special case.
                    //String Action = mDataParser.getGraph().findEdge(currentState, HintTarget);

                    hintMap.put(currentState, HintTarget);// + mDataParser.getEdgeTable().get(Action).getParameters() + Action);
                }
            }
        }
        Set<String> keySet = hintMap.keySet();
        for (Integer idx = 0; idx < keySet.size(); idx++)
        {
            String key = keySet.toArray()[idx].toString();
            mGraph.addEdge("hint - ".concat(idx.toString()), key, hintMap.get(key));

        }
    }//GEN-LAST:event_HintFactoryjButtonActionPerformed

    private void mRemoveLowMDPValueButtonActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_mRemoveLowMDPValueButtonActionPerformed
    {//GEN-HEADEREND:event_mRemoveLowMDPValueButtonActionPerformed
        this.RemoveNegativeMDPValueStates();
    }//GEN-LAST:event_mRemoveLowMDPValueButtonActionPerformed

    private void RemoveNegativeMDPValueStates()
    {
        int NodeRemovalCount = 0;
        int ErrorNodeRemovalCount = 0;
        int NonErrorNodeRemovalCount = 0;

        //Need to have some extra calculations to work around Java. No easy way
        //to copy the graph, and we are making changes to it.
        int originalEdgeSize = mGraph.getEdges().size();
        for (int i = 0; i < mGraph.getVertices().size(); i++)
        {
            String vertKey = mGraph.getVertices().toArray()[i].toString();
            Double mdpValue = mDataParser.getNodeTable().get(vertKey).getMDPValue();
            //NetworkElementApi get = mDataParser.getNodeTable().get(vertKey);
            //int F = get.getUniqueFrequency();
            if (mdpValue <= 1)
            {

                //TODO: Remove the interactions that correspond to the states which have been removed.
                for (int j = 0; j < mDataParser.getNodeTable().get(vertKey).getCaseList().size(); j++)
                {
                    //mDataParser.getNetworkCaseSet().getNetworkCaseList().get(0).getInteractionContainingState();
                    //mDataParser.getNetworkCaseSet().getNetworkCaseList().get(0).getInteractionsList().get(0).
                }
                mDataParser.getNetworkCaseSet();
                i--;
                NodeRemovalCount++;
                mGraph.removeVertex(vertKey);
                //mDataParser.getNodeTable().remove(vertKey);
            }
        }




        int EdgeRemovalCount = 0;
        /*
         EdgeRemovalCount = originalEdgeSize - mGraph.getEdges().size();
         for (int i = 0; i < mGraph.getEdges().size(); i++)
         {
         String edgeKey = mGraph.getEdges().toArray()[i].toString();
         int freq = mDataParser.getEdgeTable().get(edgeKey).getUniqueFrequency();
         if (freq <= 1)
         {
         mGraph.removeEdge(edgeKey);
         mDataParser.getEdgeTable().remove(edgeKey);
         i--;
         EdgeRemovalCount++;
         }
         }*/
        //JOptionPane.showMessageDialog(null, "Total Nodes Removed: " + NodeRemovalCount);

        //((NetworkViewerTopComponent) (WindowManager.getDefault().findTopComponent("NetworkViewerTopComponent"))).RefreshNetworkNodeContents();


        mNVV.getGraphLayout().setGraph(mGraph);
    }

    private void inDegreeFreqCalcbuttonActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_inDegreeFreqCalcbuttonActionPerformed
    {//GEN-HEADEREND:event_inDegreeFreqCalcbuttonActionPerformed
        HashMap<String, Double> extradata = new HashMap<String, Double>();
        Collection<String> keepList = new ArrayList<String>();
        Collection<String> goalList = new ArrayList<String>();
        for (int i = 0; i < mGraph.getVertices().size(); i++)
        {
            String vertKey = mGraph.getVertices().toArray()[i].toString();
            Collection<String> inEdges = mGraph.getInEdges(vertKey);

            Double SumInDegreeFrequency = 0.0;
            for (int j = 0; j < inEdges.size(); j++)
            {
                SumInDegreeFrequency += mDataParser.getEdgeTable().get(inEdges.toArray()[j].toString()).getUniqueFrequency();
            }

            //if (SumInDegreeFrequency >= 5)
            //{
            keepList.add(vertKey);
            extradata.put(vertKey, SumInDegreeFrequency);
            //}
            if (mDataParser.getNodeTable().get(vertKey).getGoalValue())
            {
                goalList.add(vertKey);
            }
        }



        /*

         for (int i = 0; i < mDataParser.getGraph().getVertices().size(); i++)
         {
         String vertKey = mDataParser.getGraph().getVertices().toArray()[i].toString();
         if (!extradata.containsKey(vertKey))
         {
         mDataParser.getGraph().removeVertex(vertKey);
         i--;
         }
         }*/
        mDataParser.SetExtraDataTable(extradata);

        //BFSDistanceLabeler y = new BFSDistanceLabeler();

        //DijkstraDistance x = new DijkstraDistance(mDataParser.getGraph());


    }//GEN-LAST:event_inDegreeFreqCalcbuttonActionPerformed

    private DirectedSparseMultigraph<String, String> CopyGraph()
    {
        DirectedSparseMultigraph<String, String> OriginalGraph = new DirectedSparseMultigraph<String, String>();
        for (int i = 0; i < mGraph.getEdgeCount(); i++)
        {
            String edge = mGraph.getEdges().toArray()[i].toString();
            String src = mGraph.getSource(edge);
            String dest = mGraph.getDest(edge);
            OriginalGraph.addEdge(edge, src, dest);
        }
        return (OriginalGraph);
    }

    private HashMap<String, Integer> GenerateNegativeWeights()
    {
        //NegativeEdgeWeights are a fix to handle high frequency actions that are followed by high frequency deletes.
        HashMap<String, Integer> NegativeEdgeWeights = new HashMap<String, Integer>();

        for (int i = 0; i < mGraph.getEdges().size(); i++)
        {
            String edgeKey = mGraph.getEdges().toArray()[i].toString();
            String action = mDataParser.getEdgeTable().get(edgeKey).getSimpleValue();

            if (action.compareTo("Del") == 0)
            {
                Integer NegativeUniqueFrequency;
                String DelSource = mGraph.getSource(edgeKey);

                //So we don't want to count the inDegree of edges that are delete.
                Integer AdjustInDegree = mGraph.inDegree(DelSource);

                Collection<String> inEdges = mGraph.getInEdges(DelSource);
                for (String edge : inEdges)
                {
                    if (edge.contains("Del"))
                    {
                        AdjustInDegree -= 1;
                    }
                }

                if (AdjustInDegree == 1)
                {
                    Collection<String> InEdge = mGraph.getInEdges(DelSource);
                    String TheInEdge = InEdge.toArray()[0].toString();
                    NegativeUniqueFrequency = mDataParser.getEdgeTable().get(edgeKey).getUniqueFrequency();
                    NegativeEdgeWeights.put(TheInEdge, NegativeUniqueFrequency);
                }
                //We also just make Delete have theoretically 0 frequency as well.
                NegativeUniqueFrequency = mDataParser.getEdgeTable().get(edgeKey).getUniqueFrequency();
                NegativeEdgeWeights.put(edgeKey, NegativeUniqueFrequency);
            }
        }
        return (NegativeEdgeWeights);
    }

    private TreeMap<String, Integer> CalculateAdjustedEdgeWeights(HashMap<String, Integer> NegativeEdgeWeights)
    {
        HashMap<String, Integer> edgeWeights = new HashMap<String, Integer>();

        for (int i = 0; i < mGraph.getEdges().size(); i++)
        {
            String edge = mGraph.getEdges().toArray()[i].toString();
            Integer AdjustedUniqueFrequency = mDataParser.getEdgeTable().get(edge).getUniqueFrequency();
            if (NegativeEdgeWeights.containsKey(edge))
            {
                AdjustedUniqueFrequency -= NegativeEdgeWeights.get(edge);
            }
            edgeWeights.put(edge, AdjustedUniqueFrequency);
        }

        ValueComparator bvc = new ValueComparator(edgeWeights);
        TreeMap<String, Integer> sorted_map = new TreeMap<String, Integer>(bvc);
        sorted_map.putAll(edgeWeights);
        return (sorted_map);
    }

    /**
     * This builds a "core" graph using the edges that have the top 10% of
     * frequencies.
     *
     */
    private DirectedSparseMultigraph<String, String> GenerateCoreGraph(TreeMap<String, Integer> sorted_map)
    {
        DirectedSparseMultigraph CoreGraph = new DirectedSparseMultigraph();
        int TopTenPercentEdges = sorted_map.entrySet().size() / 10;
        for (int i = 0; i < TopTenPercentEdges; i++)
        {
            sorted_map.entrySet().iterator().next().getValue();
            Entry<String, Integer> next = (Entry<String, Integer>) (sorted_map.entrySet().toArray()[i]);
            String edge = next.getKey();
            String source = mGraph.getSource(edge);
            String target = mGraph.getDest(edge);
            CoreGraph.addEdge(edge, source, target);
        }
        return (CoreGraph);
    }

    private void MatchMainGraphToCoreGraph(DirectedSparseMultigraph CoreGraph)
    {

        for (int i = 0; i < mGraph.getEdges().size(); i++)
        {
            String edge = mGraph.getEdges().toArray()[i].toString();
            if (!CoreGraph.containsEdge(edge))
            {
                mGraph.removeEdge(edge);
                i--;
            }
        }

        for (int i = 0; i < mGraph.getVertices().size(); i++)
        {
            String vertex = mGraph.getVertices().toArray()[i].toString();
            if (!CoreGraph.containsVertex(vertex))
            {
                mGraph.removeVertex(vertex);
                i--;
            }
        }
    }

    private Collection<String> IdentifyDisjointRoots(String Root)
    {
        /*int MaxClusterIndex = 0;
         int MaxClusterSize = 0;
         for (int clusterIterator = 0; clusterIterator < clusterSet.size(); clusterIterator++)
         {
         Set<String> cluster = (Set<String>) clusterSet.toArray()[clusterIterator];

         if (cluster.size() > MaxClusterSize)
         {
         MaxClusterSize = cluster.size();
         //MaxClusterIndex = clusterIterator;
         }
         }*/

        WeakComponentClusterer<String, String> wcSearch = new WeakComponentClusterer<String, String>();
        Set<Set<String>> clusterSet = wcSearch.transform(mGraph);
        Collection<String> DisjointRoots = new ArrayList();
        //Cycle through the Set of sets.
        for (int clusterIterator = 0; clusterIterator < clusterSet.size(); clusterIterator++)
        {
            //if (clusterIterator != MaxClusterIndex)
            //{
            Set<String> cluster = (Set<String>) clusterSet.toArray()[clusterIterator];

            //Iterate through the vertices in a cluster.
            for (int vertexIterator = 0; vertexIterator < cluster.size(); vertexIterator++)
            {
                // Find the nodes in the cluster that have no predecessors.
                if (mGraph.getPredecessorCount(cluster.toArray()[vertexIterator].toString()) == 0
                        && cluster.toArray()[vertexIterator].toString().compareTo(Root) != 0)
                {
                    DisjointRoots.add(cluster.toArray()[vertexIterator].toString());
                }
                //mDataParser.getNodeTable().get(cluster.toArray()[vertexIterator]).setClusterID(clusterIterator);
            }
            //}
        }
        return (DisjointRoots);
    }

    private Collection<String> ReconstructBasedOnShortestPaths(DirectedSparseMultigraph OriginalGraph, Collection<String> TargetList, String Root)
    {

        DijkstraShortestPath dsp = new DijkstraShortestPath(OriginalGraph);

        //Prepare a few counters for interest factor.
        int NodeCountDifference = 0;
        int SumInjectedEdgeFrequency = 0;
        int EdgeInjectorCount = 0;
        int disjointSize = TargetList.size();

        Collection<String> RemovalList = new ArrayList();

        NodeCountDifference = mGraph.getVertexCount();
        for (int i = 0; i < TargetList.size(); i++)
        {
            //Get a path from the root to a disjoint-root.
            List EdgePath = dsp.getPath(Root, TargetList.toArray()[i].toString());

            if (EdgePath.isEmpty())
            {
                //No path from route to node without delete action; Mark for Deletion.
                RemovalList.add(TargetList.toArray()[i].toString());
            }

            //Follow the path.
            for (int j = 0; j < EdgePath.size(); j++)
            {
                String edge = EdgePath.get(j).toString();
                String src = OriginalGraph.getSource(edge).toString();
                String dest = OriginalGraph.getDest(edge).toString();

                if (!mGraph.containsEdge(edge))
                {
                    //When I find a node and not in the "Core" graph, add it to the core graph.
                    mGraph.addEdge(edge, src, dest);
                    EdgeInjectorCount++;
                    SumInjectedEdgeFrequency += mDataParser.getEdgeTable().get(edge).getUniqueFrequency();
                }
            }
        }

        NodeCountDifference = mGraph.getVertexCount() - NodeCountDifference;
        /*JOptionPane.showMessageDialog(null,
         //"Size of Core Cluster: " + MaxClusterSize + "\n"
         "Disjoint Root Count: " + disjointSize + "\n"
         + "Numer of Injected Edges to Solidify the Core: " + EdgeInjectorCount + "\n"
         + "Sum of Injected Edge Unique Frequencies: " + SumInjectedEdgeFrequency + "\n"
         + "Number of Injected Nodes: " + NodeCountDifference);*/
        return (RemovalList);
    }

    private Collection<String> IdentifyNonGoalLeaves()
    {
        Collection<String> HangingLeafs = new ArrayList();
        int HangingLeafsDetected = 0;
        for (int vertexIterator = 0; vertexIterator < mGraph.getVertexCount(); vertexIterator++)
        {
            // Find the nodes in the cluster that have no predecessors.
            String vertex = mGraph.getVertices().toArray()[vertexIterator].toString();

            //We want Leaf-Nodes, ie. nodes with no successors and are NOT goals.
            if (mGraph.getSuccessorCount(vertex) == 0
                    && !mDataParser.getNodeTable().get(vertex).getGoalValue())
            {
                HangingLeafs.add(vertex);
                HangingLeafsDetected++;
            }
        }
        return (HangingLeafs);
    }

    private Collection<String> IdentifyOriginalGoalNodes(DirectedSparseMultigraph<String, String> OriginalGraph)
    {
        Collection<String> GoalNodes = new ArrayList();
        for (int originalGraphVertexItr = 0; originalGraphVertexItr < OriginalGraph.getVertexCount(); originalGraphVertexItr++)
        {
            //Get all the goal nodes from the original graph.
            String vertex = OriginalGraph.getVertices().toArray()[originalGraphVertexItr].toString();
            if (mDataParser.getNodeTable().get(vertex).getGoalValue())
            {
                //We might be tempted to ignore goals already in the reduced graph,
                //however some leaf may actually connect to that via an unrepresented path.
                //if (!mDataParser.getGraph().containsVertex(vertex))
                //{

                GoalNodes.add(vertex);
                //}

            }
        }
        return (GoalNodes);
    }

    private void PruneLeaves(Collection<String> KeepList)
    {
        Collection<String> Leaves = this.IdentifyNonGoalLeaves();
        int X = Leaves.size();
        for (int i = 0; i < Leaves.size(); i++)
        {
            if (!KeepList.contains(Leaves.toArray()[i].toString()))
            {
                mGraph.removeVertex(Leaves.toArray()[i].toString());
            }
        }
        //JOptionPane.showMessageDialog(null, "Pruned " + X + " leaves.");
        Leaves = this.IdentifyNonGoalLeaves();
        if (Leaves.size() > 0)
        {
            this.PruneLeaves(KeepList);
        }
    }

    private Collection<String> IdentifyNegativeMDPHighFreq(DirectedSparseMultigraph graph)
    {
        Collection<String> HighFreq = new ArrayList();

        for (int i = 0; i < graph.getVertexCount(); i++)
        {
            String vertex = graph.getVertices().toArray()[i].toString();
            if (mDataParser.getNodeTable().get(vertex).getMDPValue() < 0)
            {
                HighFreq.add(vertex);
            }
        }
        return (HighFreq);
    }

    /*Find all the nodes in the Core graph, that have no predecessor.
     //Add them to "free-standing" list.
     //From the Main graph, find the shortest path to the nodes in the Free-standing list.
     //Add those paths to the core graph.
     //We want to get all the non-goal leaf nodes.
     //We want to get all the original goal nodes.
     //We want to see if we can make pairs by filling in some gaps.
     //Since all nodes have positive mdp values, they can get to a goal, somehow.
     //From each goal, find the shortest path to a node in the Core Graph.
     //Get the distance for each shortest path.
     //Calculate the average distance.
     //For all paths to goal, that are less than the average, add
     //those paths to the Core graph.
     Finished.*/
    private void StrategyReduceButtonActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_StrategyReduceButtonActionPerformed
    {//GEN-HEADEREND:event_StrategyReduceButtonActionPerformed

        String Root = mRootText.getText();
        //Remove Loops.
        this.LoopRemovalFunction();

        //Calculate MDP Values.
        this.CalculateMDPValues();

        //Remove Negative MDP Value states.
        //this.RemoveNegativeMDPValueStates();

        //Calculate the negative weights.
        HashMap<String, Integer> NegativeEdgeWeights = this.GenerateNegativeWeights();

        //Remove the delete edges. Note: This MUST come after NegativeEdgeWeights!
        this.RemoveDeleteFunction();

        /* After we remove the un-wanted pieces, we generate the "Original" which we will compare against later.
         * Copy the original graph.
         * This copy and a number of functions following it, all act on mDataParser.getGraph(), So the order of these functions is VITAL!!!!
         */
        DirectedSparseMultigraph<String, String> OriginalGraph = this.CopyGraph(); //MUST TAKE GREAT CARE!!! See comment above.

        //This negative weight stuff is unnecessary. we can remove delete here,
        //because we have already calcualted the MDP Values.

        //Calculate adjusted edgeweights which consider the negative edge weights map.
        TreeMap<String, Integer> sorted_map = this.CalculateAdjustedEdgeWeights(NegativeEdgeWeights);

        //Choose the "Core" graph, the edges with the top 10% of edge frequencies.
        DirectedSparseMultigraph CoreGraph = this.GenerateCoreGraph(sorted_map);

        Collection<String> NegativeMDPHighFreq = this.IdentifyNegativeMDPHighFreq(CoreGraph);

        //Remove edges from the main graph, to match the core graph. 
        this.MatchMainGraphToCoreGraph(CoreGraph);

        //Identify any disjoint "sub-graphs".
        Collection<String> DisjointRoots = this.IdentifyDisjointRoots(Root);

        //Reconnect the disjoint pieces of the graph to the core-graph.
        Collection<String> RemovalList = this.ReconstructBasedOnShortestPaths(OriginalGraph, DisjointRoots, Root);

        this.ClearRemovalListItems(RemovalList, 0);

        //Let's try and connect all the "leaf" nodes to something already in the graph.
        //Build a list of all the hanging leaf nodes.
        Collection<String> HangingLeafs = this.IdentifyNonGoalLeaves();

        //Build a list of all the goal nodes.
        Collection<String> GoalNodes = this.IdentifyOriginalGoalNodes(OriginalGraph);



        //We add a few more nodes to the GoalNodes List. We will also accept any other node in our current reduced network.
        //By hand I discovered a case where this exists.
        Collection<String> CoreNodes = new ArrayList();
        for (int i = 0; i < mGraph.getVertexCount(); i++)
        {
            String vertex = mGraph.getVertices().toArray()[i].toString();
            CoreNodes.add(vertex);
        }

        //Try to connect to some of the existing graph if you can't connect to a goal.
        this.Solidify(HangingLeafs, CoreNodes, OriginalGraph);

        //Try to connect the graph up to some new goals within 10 states.
        //This should be towards goals not already in the Core Graph....
        this.Solidify(HangingLeafs, GoalNodes, OriginalGraph);

        //Check all core nodes to goals.
        this.Solidify(CoreNodes, GoalNodes, OriginalGraph);

        //Check all core nodes to core nodes.
        this.Solidify(CoreNodes, CoreNodes, OriginalGraph);

        //Clear Chains of nodes connected to removalList items.


        this.PruneLeaves(NegativeMDPHighFreq);

    }//GEN-LAST:event_StrategyReduceButtonActionPerformed

    private void RemoveDeleteFunction()
    {
        for (int i = 0; i < mGraph.getEdges().size(); i++)
        {
            String edgeKey = mGraph.getEdges().toArray()[i].toString();
            String action = mDataParser.getEdgeTable().get(edgeKey).getSimpleValue();
            if (action.compareTo("Del") == 0)
            {
                mGraph.removeEdge(edgeKey);
                i--;
            }
        }
    }

    private void LoopRemovalFunction()
    {
        for (int i = 0; i < mGraph.getEdges().size(); i++)
        {
            String edgeKey = mGraph.getEdges().toArray()[i].toString();
            if (mGraph.getSource(edgeKey) == null)
            {
                try
                {
                    throw new Exception("null source");
                } catch (Exception ex)
                {
                    Exceptions.printStackTrace(ex);
                }
            }

            if (mGraph.getDest(edgeKey) == null)
            {
                try
                {
                    throw new Exception("null destination");
                } catch (Exception ex)
                {
                    Exceptions.printStackTrace(ex);
                }
            }

            if (mGraph.getSource(edgeKey).compareTo(
                    mGraph.getDest(edgeKey)) == 0)
            {
                mGraph.removeEdge(edgeKey);
                i--;
            }
        }
    }

    private void ClearRemovalListItems(Collection<String> RemovalList, int index)
    {
        for (int i = index; i < RemovalList.size(); i++)
        {
            String RemoveVertex = RemovalList.toArray()[i].toString();
            if (mGraph.containsVertex(RemoveVertex))
            {
                if (mGraph.getPredecessorCount(RemoveVertex) == 0
                        || RemovalList.containsAll(mGraph.getPredecessors(RemoveVertex)))
                {
                    RemovalList.addAll(mGraph.getSuccessors(RemoveVertex));
                    mGraph.removeVertex(RemoveVertex);
                    i++;
                    this.ClearRemovalListItems(RemovalList, i);
                }
            }
        }
    }

    private void Solidify(Collection<String> HangingLeafs, Collection<String> GoalNodes, DirectedSparseMultigraph<String, String> OriginalGraph)
    {
        DijkstraShortestPath<String, String> dsp = new DijkstraShortestPath(OriginalGraph);
        int EdgeInjectorCount = 0;
        int SumInjectedEdgeFrequency = 0;
        for (int i = 0; i < HangingLeafs.size(); i++)
        {
            //Let's get all the edge paths from the current leaf, to all the goals, if they exist.
            Set<List<String>> EdgePathSet = new HashSet<List<String>>();

            for (int j = 0; j < GoalNodes.size(); j++)
            {
                List<String> EdgePath = dsp.getPath(HangingLeafs.toArray()[i].toString(), GoalNodes.toArray()[j].toString());

                //We will do a check to make sure the new paths don't contain anything from
                //our negative weights map. We made a negative weights map to de-value
                //edges which were move-forward delete actions.
                /*boolean ContainsUnwantedEdges = false;
                 for (int t = 0; t < EdgePath.size(); t++)
                 {
                 if (NegativeEdgeWeights.containsKey(EdgePath.get(t)))
                 {
                 ContainsUnwantedEdges = true;
                 }
                 }*/
                //Only add nonZero size EdgePaths. Also we don't permit some unwanted edges, from the NegativeWeights Map.
                //if (EdgePath.size() > 0 && !ContainsUnwantedEdges)
                if (EdgePath.size() > 0)// && EdgePath.size() < 10)
                {
                    EdgePathSet.add(EdgePath);
                }
            }


            //Find the smallest edge path, we've already ignored zero length Paths.
            int ShortestPathLength = 60; //We ignore anything greater than 10.
            int IndexofShortest = -1;
            for (int j = 0; j < EdgePathSet.size(); j++)
            {
                List<String> Path = (List<String>) EdgePathSet.toArray()[j];

                if (Path.size() < ShortestPathLength)
                {
                    ShortestPathLength = Path.size();
                    IndexofShortest = j;
                }
            }

            if (IndexofShortest > -1)
            {

                //Once we found a good path, add it to our graph.
                //for (int index =0;index<EdgePathSet.size();index++)
                //{
                List<String> EdgePath = (List<String>) EdgePathSet.toArray()[IndexofShortest];
                //List<String> EdgePath = (List<String>) EdgePathSet.toArray()[index];
                for (int k = 0; k < EdgePath.size(); k++)
                {
                    String edge = EdgePath.get(k).toString();
                    String src = OriginalGraph.getSource(edge);
                    String dest = OriginalGraph.getDest(edge);

                    //I should count how many things get connected.
                    //ConnectedCounter++;
                    if (!mGraph.containsEdge(edge))
                    {
                        //When I find a node and not in the "Core" graph, add it to the core graph.
                        mGraph.addEdge(edge, src, dest);
                        EdgeInjectorCount++;
                        SumInjectedEdgeFrequency += mDataParser.getEdgeTable().get(edge).getUniqueFrequency();
                    }
                }
            }
        }
        /*JOptionPane.showMessageDialog(null,
         "Input Node Count: " + HangingLeafs.size() + "\n"
         + "Numer of Injected Edges to Solidify the Core: " + EdgeInjectorCount + "\n");*/

    }

    private void mGoalShortestPathsButtonActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_mGoalShortestPathsButtonActionPerformed
    {//GEN-HEADEREND:event_mGoalShortestPathsButtonActionPerformed
        DirectedSparseMultigraph originalgraph = this.CopyGraph();
        Collection<String> GoalNodes = this.IdentifyOriginalGoalNodes(originalgraph);

        for (int i = 0; i < mGraph.getEdges().size(); i++)
        {
            String edgeKey = mGraph.getEdges().toArray()[i].toString();
            mGraph.removeEdge(edgeKey);
            i--;
        }
        for (int i = 0; i < mGraph.getVertices().size(); i++)
        {
            String edgeKey = mGraph.getVertices().toArray()[i].toString();
            mGraph.removeVertex(edgeKey);
            i--;
        }

        this.ReconstructBasedOnShortestPaths(originalgraph, GoalNodes, mRootText.getText());
    }//GEN-LAST:event_mGoalShortestPathsButtonActionPerformed

    private void mBubbleDetectorjbtnActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_mBubbleDetectorjbtnActionPerformed
    {//GEN-HEADEREND:event_mBubbleDetectorjbtnActionPerformed

        //Get all out degree 2+ vertices from the graph.
        ArrayList<String> OutDegree2Vertices = new ArrayList<String>(); //Source list.
        for (int i = 0; i < mGraph.getVertexCount(); i++)
        {
            String vertex = mGraph.getVertices().toArray()[i].toString();
            if (mGraph.outDegree(vertex) > 1 && !vertex.matches(mRootText.getText()))
            {
                OutDegree2Vertices.add(vertex);
            }
        }

        //Get all In Degree 2+ vertices from the graph.
        ArrayList<String> InDegree2Vertices = new ArrayList<String>(); //Target list.
        for (int i = 0; i < mGraph.getVertexCount(); i++)
        {
            String vertex = mGraph.getVertices().toArray()[i].toString();
            if (mGraph.inDegree(vertex) > 1)
            {
                InDegree2Vertices.add(vertex);
            }
        }

        //Go through the lists, identify if there is a path from the Source list, to the target list.
        //If there is no path, we can ignore it.
        DijkstraShortestPath<String, String> dsp = new DijkstraShortestPath(mGraph);
        dsp.setMaxDistance(5);

        List<List<String>> PathList = new ArrayList<List<String>>();

        for (int i = 0; i < OutDegree2Vertices.size(); i++)
        {

            String source = OutDegree2Vertices.get(i).toString();
            for (int j = 0; j < InDegree2Vertices.size(); j++)
            {
                String target = InDegree2Vertices.get(j).toString();
                List<String> path = dsp.getPath(source, target);
                if (!path.isEmpty())
                {
                    PathList.add(path);
                }
            }
        }

        //The PathList stores all the combos between our source and target vertices,
        // and shows that there exists a path between the two.
        //Now we will will iterate that PathList, and remove and pair of source and target
        //vertices that do not contain multiple paths between the two.

        List<List<String>> BubblePathList = new ArrayList<List<String>>();
        for (int i = 0; i < PathList.size(); i++)
        {
            //Get the Source Vertex.
            String FirstEdge = PathList.get(i).get(0).toString();
            String SrcVertex = mGraph.getSource(FirstEdge);
            //Get the target vertex.
            String LastEdge = PathList.get(i).get(PathList.get(i).size() - 1);
            String TgtVertex = mGraph.getDest(LastEdge);

            //List<List<String>> allPathsBetweenNodes = AllPathDetector.getAllUniqePathsBetweenNodes(mDataParser.getGraph(), SrcVertex, TgtVertex, 5);
            AllPathDetector x = new AllPathDetector<String, String>();
            List<List<String>> allPathsBetweenNodes = x.getAllUniqePathsBetweenNodes(mGraph, SrcVertex, TgtVertex, 5);
            if (allPathsBetweenNodes.size() > 1)
            {
                //Next we want to identify distinct paths, or unique paths, from our allPathsBetweenNodes.
                for (int j = 0; j < allPathsBetweenNodes.size(); j++)
                {
                    BubblePathList.add(allPathsBetweenNodes.get(j));
                }
            }
        }
    }//GEN-LAST:event_mBubbleDetectorjbtnActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel FrequencyFilterjLabel3;
    private javax.swing.JButton GoalPathNodesSelector;
    private javax.swing.JButton HintFactoryjButton;
    private javax.swing.JButton StrategyReduceButton;
    private javax.swing.JButton inDegreeFreqCalcbutton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JButton mBubbleDetectorjbtn;
    private javax.swing.JButton mGoalShortestPathsButton;
    private javax.swing.JButton mMdpCalculateButton;
    private javax.swing.JButton mRemoveLowMDPValueButton;
    private javax.swing.JTextField mRootText;
    private GuiElements.RangeSlider mdpValueSlider;
    // End of variables declaration//GEN-END:variables

    @Override
    public void componentOpened()
    {
        mDataParser = Lookup.getDefault().lookup(DataParser.class);
        this.buildMDPValueSlider();
    }

    @Override
    public void componentClosed()
    {
        // TODO add custom code on component closing
    }

    void writeProperties(java.util.Properties p)
    {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p)
    {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }

    @Override
    public void UpdateCurrentVV(NetworkVisualizationViewer currentVV, DisplayType type)
    {
        if (mDataParser.hasData())
        {
            if (type == DisplayType.NETWORK)
            {
                mNVV = currentVV;
                //mDisplayTypeFlag = type;
                mGraph = (DirectedSparseMultigraph<String, String>) mNVV.getGraphLayout().getGraph();
            }
            if (type == DisplayType.STEPBASED)
            {
            }
        } else
        {
            this.close();
        }
    }

    /*@Override
     public void RefreshContents()
     {
     throw new UnsupportedOperationException("Not supported yet.");
     }*/
    @Override
    public void ClearContents()
    {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    class ValueComparator implements Comparator<String>
    {

        Map<String, Integer> base;

        public ValueComparator(Map<String, Integer> base)
        {
            this.base = base;
        }

        // Note: this comparator imposes orderings that are inconsistent with equals.    
        @Override
        public int compare(String a, String b)
        {
            if (base.get(a) < base.get(b))
            {
                return 1;
            } else if (base.get(a) == base.get(b))
            {
                return 1;
            } // returning 0 would merge keys
            else
            {
                return -1;
            }
        }
    }
}
