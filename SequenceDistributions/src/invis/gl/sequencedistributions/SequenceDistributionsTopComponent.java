package invis.gl.sequencedistributions;

import NetworkApi.NetworkElementApi;
import invis.gl.dataprocessor.DataParser;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import org.apache.commons.collections15.Bag;
import org.apache.commons.collections15.bag.HashBag;
import org.apache.commons.collections15.iterators.UniqueFilterIterator;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.util.Lookup;
import org.openide.util.NbBundle.Messages;
import org.openide.windows.TopComponent;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(dtd = "-//invis.gl.sequencedistributions//SequenceDistributions//EN",
autostore = false)
@TopComponent.Description(preferredID = "SequenceDistributionsTopComponent",
//iconBase="SET/PATH/TO/ICON/HERE", 
persistenceType = TopComponent.PERSISTENCE_ALWAYS)
@TopComponent.Registration(mode = "editor", openAtStartup = false)
@ActionID(category = "Window", id = "invis.gl.sequencedistributions.SequenceDistributionsTopComponent")
@ActionReference(path = "Menu/Window" /*
 * , position = 333
 */)
@TopComponent.OpenActionRegistration(displayName = "#CTL_SequenceDistributionsAction",
preferredID = "SequenceDistributionsTopComponent")
@Messages(
{
    "CTL_SequenceDistributionsAction=SequenceDistributions",
    "CTL_SequenceDistributionsTopComponent=SequenceDistributions Window",
    "HINT_SequenceDistributionsTopComponent=This is a SequenceDistributions window"
})
public final class SequenceDistributionsTopComponent extends TopComponent {

    private DataParser mDataParser;
    private HashMap<String, NetworkElementApi> nodeTable;

    public SequenceDistributionsTopComponent() {
        initComponents();
        setName(Bundle.CTL_SequenceDistributionsTopComponent());
        setToolTipText(Bundle.HINT_SequenceDistributionsTopComponent());

        mDataParser = Lookup.getDefault().lookup(DataParser.class);
        nodeTable = mDataParser.getNodeTable();

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 278, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
    // End of variables declaration//GEN-END:variables

    @Override
    public void componentOpened() {

        //TODO: The GetCaseStates function does not have a way to calculate the frequency, a single student has, for visits to the same state...
        //ANOTE: Still not fixed

        jTextArea1.setEditable(false);
        //final Bag<String> states = new TreeBag<String>();
        final Bag<ArrayList<String>> states = new HashBag<ArrayList<String>>();
        //final Bag<String> actions = new TreeBag<String>();
        final Bag<ArrayList<String>> actions = new HashBag<ArrayList<String>>();

        ArrayList<String> CaseStateList = new ArrayList();
        ArrayList<String> CaseActionList = new ArrayList();

        //Iterate through all of the cases.
        /*
         * for (int i = 0; i < mDataParser.getCaseSet().getCaseSetSize(); i++) {
         * //For each case, get their CaseStateList. CaseStateList =
         * mDataParser.GetCaseStates(i); //For each state in the case list,
         * check if it is in our master list, StateList. for (int j = 0; j <
         * CaseStateList.size(); j++) { //if it is not contained, add it. if
         * (!StateList.contains(CaseStateList.get(j))) {
         * StateList.add(CaseStateList.get(j)); FrequencyList.add(1);
         * //FrequencyList.set(StateList.size()-1, 1); } else { int idx =
         * StateList.indexOf(CaseStateList.get(j)); int prevFrequency =
         * FrequencyList.get(idx); FrequencyList.set(idx, prevFrequency+1); } }
         * }
         *
         * for (int i = 0; i < StateList.size(); i++) {
         * jTextArea1.append(StateList.get(i) +" " + FrequencyList.get(i) +
         * "\n"); }
         */

        if (mDataParser.hasData()) {
            //Iterate through all the cases.
            for (int i = 0; i < mDataParser.getCaseSet().getCaseSetSize(); i++) {
                CaseStateList = mDataParser.GetCaseStates(i);
                //we're also going to get all the sets of states (pair, triplets, etc.) so we define the 
                //current end of the number of states we want to check for.
                for (int k = 0; k < CaseStateList.size(); k++)//ANOTE: Super inefficient
                {
                    //Iterate through our list of states. notice the j+k < list.size.
                    for (int j = 0; j + k < CaseStateList.size(); j++) {
                        //String search = "";
                        ArrayList<String> search = new ArrayList<String>();
                        //Biuld our current string we are matching for, which is either 2 elements, 3, 4, and so on.
                        for (int m = 0; m < k + 1; m++) {
                            //search += CaseStateList.get(j + m);
                            search.add(CaseStateList.get(j + m));
                        }
                        states.add(search); //add state to bag
                    }
                }

                //Build the same for actions...
                CaseActionList = mDataParser.getCaseActions(i);
                for (int k = 0; k < CaseActionList.size(); k++) {
                    for (int j = 0; j + k < CaseActionList.size(); j++) {
                        //String search = "";
                        ArrayList<String> search = new ArrayList<String>();
                        for (int m = 0; m < k; m++) {
                            //search += CaseActionList.get(j + m);
                            search.add(CaseActionList.get(j + m));
                        }
                        actions.add(search);
                    }
                }
            }
        }

        Iterator stateIterator = new UniqueFilterIterator(states.iterator());
        jTextArea1.append("States:\n");
        while (stateIterator.hasNext()) {
            ArrayList<String> state = (ArrayList<String>) stateIterator.next();
            jTextArea1.append(state + " " + states.getCount(state) + "\n");
            ArrayList<NetworkElementApi> nodeList = new ArrayList<NetworkElementApi>();
            for(String st : state) {
                nodeList.add(nodeTable.get(st));
            }
            System.out.println(nodeList);
        }
       

        Iterator actionsIterator = new UniqueFilterIterator(actions.iterator());
        jTextArea1.append("\n" + "Actions:\n");
        while (actionsIterator.hasNext()) {
            ArrayList<String> action = (ArrayList<String>) actionsIterator.next();
            jTextArea1.append(action + " " + actions.getCount(action) + "\n");
        }

    }

    @Override
    public void componentClosed() {
        jTextArea1.setText("");
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p) {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }
}
